<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown 查看器与目录</title>

    <!-- 引入 GitHub 风格 Markdown 暗黑模式样式 -->
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown-dark.min.css" />

    <style>
        body {
            margin: 0;
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            display: flex; /* 使用 Flexbox 布局 */
            min-height: 100vh;
        }

        #sidebar {
            width: 280px;
            min-width: 200px;
            max-width: 400px;
            background-color: #161b22; /* GitHub Darker Sidebar */
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #30363d; /* GitHub Dark Border */
            height: 100vh; /* 使侧边栏撑满视口高度 */
            box-sizing: border-box;
        }

        #sidebar h3 {
            margin-top: 0;
            color: #8b949e; /* GitHub Dark Secondary Text */
            border-bottom: 1px solid #30363d;
            padding-bottom: 10px;
        }

        #directory-tree ul {
            list-style-type: none;
            padding-left: 15px;
        }

        #directory-tree li {
            margin-bottom: 5px;
        }

        #directory-tree a {
            color: #58a6ff; /* GitHub Dark Link */
            text-decoration: none;
            cursor: pointer;
        }
        #directory-tree a:hover {
            text-decoration: underline;
        }
        .folder {
            font-weight: bold;
            color: #c9d1d9; /* GitHub Dark Text */
        }
        .file { /* Style for non-markdown files */
            color: #8b949e; /* GitHub Dark Secondary Text */
        }
        .file-md {
            /* Can add specific styles for Markdown files if needed */
        }


        #main-content {
            flex-grow: 1; /* 主内容区域占据剩余空间 */
            overflow-y: auto; /* 内容过多时主内容区滚动 */
            height: 100vh; /* 主内容区域也撑满视口高度 */
            box-sizing: border-box;
        }

        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }

        @media (max-width: 767px) {
            body {
                flex-direction: column; /* 移动端上下布局 */
            }
            #sidebar {
                width: 100%;
                max-width: none;
                height: auto; /* 移动端高度自适应 */
                max-height: 40vh; /* 给侧边栏一个最大高度 */
                border-right: none;
                border-bottom: 1px solid #30363d;
            }
            #main-content {
                height: auto;
            }
            .markdown-body {
                padding: 15px;
            }
        }
    </style>
</head>

<body>
    <div id="sidebar">
        <h3>文件目录</h3>
        <div id="directory-tree">正在加载目录...</div>
    </div>

    <div id="main-content">
        <div id="content" class="markdown-body">
            正在加载...
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>

    <!-- 1. Application Configuration -->
    <script>
        const AppConfig = {
            GITHUB_OWNER: null,
            GITHUB_REPO: null,
            // --- 用户可能需要根据实际情况修改以下配置 ---
            // GitHub Pages 发布源的分支 (e.g., 'main', 'master', 'gh-pages')
            GITHUB_BRANCH: 'main',
            // 如果 GitHub Pages 是从仓库的子目录 (如 'docs') 发布的，请设置此项
            // 例如: 'docs'。如果从根目录发布，则留空 ''
            PAGES_ROOT_IN_REPO: '',
            // --------------------------------------------
            DEFAULT_MARKDOWN_FILE: 'README.md',
            API_BASE_URL: 'https://api.github.com',
            // 如果是私有仓库，需要设置 Personal Access Token (不推荐直接硬编码在前端)
            // GITHUB_TOKEN: 'YOUR_PERSONAL_ACCESS_TOKEN_HERE',

            // DOM Element IDs
            SIDEBAR_TREE_ID: 'directory-tree',
            MAIN_CONTENT_ID: 'content'
        };
    </script>

    <!-- 2. GitHub API Utilities -->
    <script>
        function inferGitHubPagesConfig() {
            const hostname = window.location.hostname;
            const pathname = window.location.pathname;

            AppConfig.GITHUB_OWNER = hostname.split('.')[0];

            if (hostname === `${AppConfig.GITHUB_OWNER}.github.io`) { // 用户/组织页面
                AppConfig.GITHUB_REPO = `${AppConfig.GITHUB_OWNER}.github.io`;
                // 对于用户/组织页面，通常 GITHUB_BRANCH 是 'main' 或 'master'，PAGES_ROOT_IN_REPO 是 ''
                // AppConfig.GITHUB_BRANCH 保持默认 'main'
                // AppConfig.PAGES_ROOT_IN_REPO 保持默认 ''
            } else { // 项目页面 (username.github.io/repo-name/)
                const pathSegments = pathname.split('/').filter(Boolean);
                if (pathSegments.length > 0) {
                    AppConfig.GITHUB_REPO = pathSegments[0];
                    // 对于项目页面，发布源可能是 'main'/'master' 的根目录或 '/docs'，也可能是 'gh-pages' 分支。
                    // AppConfig.GITHUB_BRANCH 和 AppConfig.PAGES_ROOT_IN_REPO 保持默认。
                    // 用户需要根据实际情况在 AppConfig 中调整。
                    // 例如，如果从 'gh-pages' 分支发布，则设置 AppConfig.GITHUB_BRANCH = 'gh-pages';
                    // 例如，如果从 'main' 分支的 'docs' 目录发布，则设置 AppConfig.PAGES_ROOT_IN_REPO = 'docs';
                } else {
                    console.warn("无法从路径推断项目仓库名。请检查 AppConfig 或手动配置。");
                    AppConfig.GITHUB_REPO = `${AppConfig.GITHUB_OWNER}.github.io`; // Fallback
                }
            }
            console.log(`推断配置: Owner=${AppConfig.GITHUB_OWNER}, Repo=${AppConfig.GITHUB_REPO}. (请确认 Branch: ${AppConfig.GITHUB_BRANCH}, Pages Root: '${AppConfig.PAGES_ROOT_IN_REPO}' 是否正确)`);
        }

        async function fetchGitHubTree() {
            if (!AppConfig.GITHUB_OWNER || !AppConfig.GITHUB_REPO || !AppConfig.GITHUB_BRANCH) {
                console.error("GitHub 配置不完整！ (Owner, Repo, Branch)");
                return null;
            }
            const apiUrl = `${AppConfig.API_BASE_URL}/repos/${AppConfig.GITHUB_OWNER}/${AppConfig.GITHUB_REPO}/git/trees/${AppConfig.GITHUB_BRANCH}?recursive=1`;
            console.log(`Fetching tree from: ${apiUrl}`);
            try {
                const headers = { "Accept": "application/vnd.github.v3+json" };
                if (AppConfig.GITHUB_TOKEN) { // 用于私有仓库
                    // headers["Authorization"] = `token ${AppConfig.GITHUB_TOKEN}`;
                    console.warn("注意：在前端使用 GitHub Token 有安全风险。");
                }
                const response = await fetch(apiUrl, { headers });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`GitHub API Error: ${response.status} - ${errorData.message}`);
                }
                const data = await response.json();
                if (data.truncated) {
                    console.warn("GitHub API 返回的树信息被截断，可能无法显示所有文件。");
                }
                return data.tree;
            } catch (error) {
                console.error('获取 GitHub 目录树失败:', error);
                document.getElementById(AppConfig.SIDEBAR_TREE_ID).innerHTML =
                    `<p style="color:red;">加载目录失败: ${error.message}</p>
                     <p>请检查控制台获取更多信息，并确认 AppConfig 中的 GitHub 配置 (Owner, Repo, Branch, Pages Root) 是否正确。</p>`;
                return null;
            }
        }

        function buildTree(items) {
            const tree = {};
            if (!items) return tree;

            items.forEach(item => {
                let effectivePath = item.path;
                if (AppConfig.PAGES_ROOT_IN_REPO) {
                    if (item.path.startsWith(AppConfig.PAGES_ROOT_IN_REPO + '/')) {
                        effectivePath = item.path.substring(AppConfig.PAGES_ROOT_IN_REPO.length + 1);
                    } else if (item.path === AppConfig.PAGES_ROOT_IN_REPO) { // The root dir itself
                        return; // Don't list the root dir as an item if it's the base
                    }
                     else { // Not in the pages root, skip
                        return;
                    }
                }
                if (!effectivePath) return;

                const parts = effectivePath.split('/');
                let currentLevel = tree;
                parts.forEach((part, index) => {
                    if (!currentLevel[part]) {
                        currentLevel[part] = { _type: (item.type === 'tree' || index < parts.length -1) ? 'folder' : 'file', _children: {} };
                    }
                    if (index === parts.length - 1) { // Last part
                        currentLevel[part]._type = (item.type === 'blob') ? 'file' : 'folder';
                        if (item.type === 'blob') {
                             currentLevel[part]._path = effectivePath; // Store relative path for files
                        }
                    }
                    currentLevel = currentLevel[part]._children;
                });
            });
            return tree;
        }
    </script>

    <!-- 3. Directory Renderer -->
    <script>
        function renderTree(node, currentPath = '') {
            let html = '<ul>';
            const sortedKeys = Object.keys(node).sort((a, b) => {
                const aIsDir = node[a]._type === 'folder';
                const bIsDir = node[b]._type === 'folder';
                if (aIsDir && !bIsDir) return -1;
                if (!aIsDir && bIsDir) return 1;
                return a.localeCompare(b);
            });

            for (const key of sortedKeys) {
                const item = node[key];
                html += '<li>';
                if (item._type === 'folder') {
                    html += `<span class="folder">${key}</span>`;
                    if (Object.keys(item._children).length > 0) {
                        html += renderTree(item._children, item._path || (currentPath ? `${currentPath}/${key}` : key) );
                    }
                } else if (item._type === 'file') {
                    const filePath = item._path; // Should always exist for files from buildTree
                    if (key.toLowerCase().endsWith('.md')) {
                        html += `<a href="#${filePath}" class="file-md">${key}</a>`;
                    } else {
                        html += `<span class="file">${key}</span>`; // Display non-markdown files as text
                    }
                }
                html += '</li>';
            }
            html += '</ul>';
            return html;
        }

        async function displayDirectoryTree() {
            const directoryElement = document.getElementById(AppConfig.SIDEBAR_TREE_ID);
            if (!directoryElement) {
                console.error(`目录元素 #${AppConfig.SIDEBAR_TREE_ID} 未找到!`);
                return;
            }
            directoryElement.innerHTML = '正在加载目录...';
            const treeItems = await fetchGitHubTree();
            if (treeItems) {
                const directoryData = buildTree(treeItems);
                const treeHtml = renderTree(directoryData);
                directoryElement.innerHTML = treeHtml || '<p>目录为空或未找到 Markdown 文件。</p>';
            }
        }
    </script>

    <!-- 4. Markdown Renderer -->
    <script>
        async function loadMarkdown(filename) {
            const contentDiv = document.getElementById(AppConfig.MAIN_CONTENT_ID);
            if (!contentDiv) {
                console.error(`内容元素 #${AppConfig.MAIN_CONTENT_ID} 未找到!`);
                return;
            }
            console.log(`尝试加载 Markdown: ${filename}`);
            contentDiv.innerHTML = '正在加载...';
            document.title = `加载中 - ${filename}`;

            try {
                const response = await fetch(filename); // filename is relative to site root
                if (!response.ok) {
                    throw new Error(`获取文件失败: ${response.status} ${response.statusText} (文件: ${filename})`);
                }
                const markdownText = await response.text();
                const htmlContent = marked.parse(markdownText);
                contentDiv.innerHTML = htmlContent;
                document.title = filename;
                console.log(`成功加载并渲染: ${filename}`);
            } catch (error) {
                console.error('加载 Markdown 失败:', error);
                contentDiv.innerHTML = `<p style="color:red;">加载 <strong>${filename}</strong> 失败。</p><p>${error.message}</p><p>请确保文件存在并且路径正确。</p>`;
                document.title = `加载失败 - ${filename}`;
            }
        }
    </script>

    <!-- 5. Main Application Logic -->
    <script>
        function checkHashAndLoad() {
            let filename = window.location.hash.substring(1);
            if (!filename) {
                const firstMdLink = document.querySelector(`#${AppConfig.SIDEBAR_TREE_ID} a.file-md`);
                if (firstMdLink) {
                    filename = firstMdLink.getAttribute('href').substring(1);
                    // Update hash to reflect the default file, this will trigger hashchange again
                    window.location.hash = '#' + filename;
                    return; // Let the new hashchange event handle the loading
                } else {
                    filename = AppConfig.DEFAULT_MARKDOWN_FILE;
                }
            }
            // No specific check for .md here, as hash might point to a non-md file
            // that the user intentionally wants to try (though loadMarkdown might fail)
            // Or, we could enforce .md here or in loadMarkdown.
            // For now, loadMarkdown will handle non-fetchable files.
            if (filename) { // Only load if a filename is determined
                loadMarkdown(filename);
            } else {
                 document.getElementById(AppConfig.MAIN_CONTENT_ID).innerHTML = `<p>请从目录中选择一个文件，或确保 <code>${AppConfig.DEFAULT_MARKDOWN_FILE}</code> 文件存在。</p>`;
                 document.title = "请选择文件";
            }
        }

        async function initializeApp() {
            inferGitHubPagesConfig();
            await displayDirectoryTree(); // Load directory first
            checkHashAndLoad();       // Then load content based on hash or default
        }

        window.addEventListener('DOMContentLoaded', initializeApp);
        window.addEventListener('hashchange', checkHashAndLoad);
    </script>

</body>
</html>