<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown 查看器与目录</title>

    <!-- 引入 GitHub 风格 Markdown 暗黑模式样式 -->
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown-dark.min.css" />

    <style>
        body {
            margin: 0;
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            display: flex; /* 使用 Flexbox 布局 */
            min-height: 100vh;
        }

        #sidebar {
            width: 280px;
            min-width: 200px;
            max-width: 400px;
            background-color: #161b22; /* GitHub Darker Sidebar */
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #30363d; /* GitHub Dark Border */
            height: 100vh; /* 使侧边栏撑满视口高度 */
            box-sizing: border-box;
        }

        #sidebar h3 {
            margin-top: 0;
            color: #8b949e; /* GitHub Dark Secondary Text */
            border-bottom: 1px solid #30363d;
            padding-bottom: 10px;
        }

        #directory-tree ul {
            list-style-type: none;
            padding-left: 15px;
        }

        #directory-tree li {
            margin-bottom: 5px;
        }

        #directory-tree a {
            color: #58a6ff; /* GitHub Dark Link */
            text-decoration: none;
            cursor: pointer;
        }
        #directory-tree a:hover {
            text-decoration: underline;
        }
        .folder {
            font-weight: bold;
            color: #c9d1d9; /* GitHub Dark Text */
        }
        .file-md {
            /* 可以为 Markdown 文件添加特定样式，如果需要 */
        }


        #main-content {
            flex-grow: 1; /* 主内容区域占据剩余空间 */
            overflow-y: auto; /* 内容过多时主内容区滚动 */
            height: 100vh; /* 主内容区域也撑满视口高度 */
            box-sizing: border-box;
        }

        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }

        @media (max-width: 767px) {
            body {
                flex-direction: column; /* 移动端上下布局 */
            }
            #sidebar {
                width: 100%;
                max-width: none;
                height: auto; /* 移动端高度自适应 */
                max-height: 40vh; /* 给侧边栏一个最大高度 */
                border-right: none;
                border-bottom: 1px solid #30363d;
            }
            #main-content {
                height: auto;
            }
            .markdown-body {
                padding: 15px;
            }
        }
    </style>
</head>

<body>
    <div id="sidebar">
        <h3>文件目录</h3>
        <div id="directory-tree">正在加载目录...</div>
    </div>

    <div id="main-content">
        <div id="content" class="markdown-body">
            正在加载...
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>

    <script>
        // --- 配置 ---
        // 自动从 GitHub Pages URL 推断，或者手动配置
        // 例如：对于 https://username.github.io/my-repo/
        // let GITHUB_OWNER = "username";
        // let GITHUB_REPO = "my-repo";
        // let GITHUB_BRANCH = "gh-pages"; // 或者 "main" 如果 Pages 从 main 的 /docs 文件夹部署
        // let PAGES_ROOT_IN_REPO = ""; // 如果 Pages 从仓库根目录部署
        // let PAGES_ROOT_IN_REPO = "docs"; // 如果 Pages 从 main 分支的 /docs 文件夹部署

        let GITHUB_OWNER;
        let GITHUB_REPO;
        let GITHUB_BRANCH = 'main'; // 默认分支，通常是 main 或 master
        let PAGES_ROOT_IN_REPO = ''; // 默认为空，表示 Pages 从仓库根目录部署

        function inferGitHubPagesConfig() {
            const hostname = window.location.hostname; // e.g., "username.github.io"
            const pathname = window.location.pathname; // e.g., "/repo-name/" or "/repo-name/path/to/page.html"

            GITHUB_OWNER = hostname.split('.')[0];

            // 尝试推断仓库名和分支
            // 1. 用户/组织页面: username.github.io
            if (hostname === `${GITHUB_OWNER}.github.io` && (pathname === '/' || pathname.split('/')[1] === '' || !pathname.split('/')[1])) {
                GITHUB_REPO = `${GITHUB_OWNER}.github.io`;
                GITHUB_BRANCH = 'main'; // 或者 'master'，通常用户页面是 main/master 分支根目录
                PAGES_ROOT_IN_REPO = '';
            }
            // 2. 项目页面: username.github.io/repo-name/
            else {
                const pathSegments = pathname.split('/').filter(Boolean); // ["repo-name", "path", "to", "page.html"]
                if (pathSegments.length > 0) {
                    GITHUB_REPO = pathSegments[0];
                    // 对于项目页面，GitHub Pages 通常从 gh-pages 分支的根目录，
                    // 或者 main/master 分支的 /docs 目录，或者 main/master 分支的根目录。
                    // 这里我们做一个合理的猜测，但可能需要用户根据实际情况调整。
                    // 默认猜测是 gh-pages 分支，如果不是，用户需要手动修改 GITHUB_BRANCH 和 PAGES_ROOT_IN_REPO
                    GITHUB_BRANCH = 'gh-pages'; // 这是一个常见的设置
                    // 检查是否可能从 main/master 的 /docs 部署 (这是一个启发式方法，不完美)
                    // 或者从 main/master 根目录部署
                    // 为了简化，我们先假设 gh-pages 或 main/master 根目录
                    // 如果用 main/master + /docs, 用户需要设置 PAGES_ROOT_IN_REPO = "docs" 和 GITHUB_BRANCH = "main"

                } else {
                     // 这种情况比较少见，可能是根域名直接指向一个 Pages 仓库但不是 user/org page
                     // 需要用户手动配置
                    console.warn("无法完全自动推断仓库名，请检查或手动配置 GITHUB_REPO。");
                    GITHUB_REPO = `${GITHUB_OWNER}.github.io`; //  fallback
                }
            }
             console.log(`推断配置: Owner=${GITHUB_OWNER}, Repo=${GITHUB_REPO}, Branch=${GITHUB_BRANCH}, RootInRepo=${PAGES_ROOT_IN_REPO}`);
        }

        // --- GitHub API 调用 ---
        async function fetchGitHubTree() {
            if (!GITHUB_OWNER || !GITHUB_REPO || !GITHUB_BRANCH) {
                console.error("GitHub 配置不完整！");
                return null;
            }
            const apiUrl = `https://api.github.com/repos/${GITHUB_OWNER}/${GITHUB_REPO}/git/trees/${GITHUB_BRANCH}?recursive=1`;
            console.log(`Fetching tree from: ${apiUrl}`);
            try {
                const response = await fetch(apiUrl, {
                    headers: {
                        "Accept": "application/vnd.github.v3+json"
                        // 如果是私有仓库，需要添加 Authorization header:
                        // "Authorization": "token YOUR_PERSONAL_ACCESS_TOKEN"
                    }
                });
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`GitHub API Error: ${response.status} - ${errorData.message}`);
                }
                const data = await response.json();
                if (data.truncated) {
                    console.warn("GitHub API 返回的树信息被截断，可能无法显示所有文件。");
                }
                return data.tree; // 返回文件/目录对象数组
            } catch (error) {
                console.error('获取 GitHub 目录树失败:', error);
                document.getElementById('directory-tree').innerHTML = `<p style="color:red;">加载目录失败: ${error.message}</p><p>请检查控制台获取更多信息，并确认 GitHub 配置 (Owner, Repo, Branch, Pages Root) 是否正确。</p>`;
                return null;
            }
        }

        // --- 构建和渲染目录树 ---
        function buildTree(items) {
            const tree = {};
            items.forEach(item => {
                // 如果 Pages 是从仓库的子目录（如 'docs/'）部署的，我们需要处理路径
                let effectivePath = item.path;
                if (PAGES_ROOT_IN_REPO && item.path.startsWith(PAGES_ROOT_IN_REPO + '/')) {
                    effectivePath = item.path.substring(PAGES_ROOT_IN_REPO.length + 1);
                } else if (PAGES_ROOT_IN_REPO && item.path === PAGES_ROOT_IN_REPO) {
                    // 如果项目本身就是这个 docs 目录，则忽略
                    return;
                } else if (PAGES_ROOT_IN_REPO) {
                    // 不在 PAGES_ROOT_IN_REPO 下的文件/目录，不显示
                    return;
                }
                if (!effectivePath) return; // 忽略根路径本身

                const parts = effectivePath.split('/');
                let currentLevel = tree;
                parts.forEach((part, index) => {
                    if (!currentLevel[part]) {
                        currentLevel[part] = { _type: 'folder', _children: {} };
                    }
                    if (index === parts.length - 1) { // 最后一节
                        if (item.type === 'blob') { // 文件
                            currentLevel[part]._type = 'file';
                            currentLevel[part]._path = effectivePath; // 存储相对于 Pages 部署根目录的路径
                        } else if (item.type === 'tree') { // 目录 (API 也会列出目录本身)
                             currentLevel[part]._type = 'folder';
                        }
                    }
                    currentLevel = currentLevel[part]._children;
                });
            });
            return tree;
        }

        function renderTree(node, currentPath = '') {
            let html = '<ul>';
            const sortedKeys = Object.keys(node).sort((a, b) => {
                // 文件夹优先，然后按字母排序
                const aIsDir = node[a]._type === 'folder';
                const bIsDir = node[b]._type === 'folder';
                if (aIsDir && !bIsDir) return -1;
                if (!aIsDir && bIsDir) return 1;
                return a.localeCompare(b);
            });

            for (const key of sortedKeys) {
                const item = node[key];
                const itemPath = item._path || (currentPath ? `${currentPath}/${key}` : key);

                html += '<li>';
                if (item._type === 'folder') {
                    html += `<span class="folder">${key}</span>`;
                    if (Object.keys(item._children).length > 0) {
                        html += renderTree(item._children, itemPath);
                    }
                } else if (item._type === 'file') {
                    if (key.toLowerCase().endsWith('.md')) {
                        html += `<a href="#${itemPath}" class="file-md">${key}</a>`;
                    } else {
                        // html += `<span>${key}</span>`; // 非 Markdown 文件，仅显示
                        // 或者提供下载链接 (需要 item.url or sha to construct raw link if desired)
                    }
                }
                html += '</li>';
            }
            html += '</ul>';
            return html;
        }

        async function displayDirectoryTree() {
            const treeItems = await fetchGitHubTree();
            if (treeItems) {
                const directoryData = buildTree(treeItems);
                const treeHtml = renderTree(directoryData);
                document.getElementById('directory-tree').innerHTML = treeHtml || '<p>目录为空或无 Markdown 文件。</p>';
            }
        }

        // --- Markdown 加载 ---
        const contentDiv = document.getElementById('content');

        async function loadMarkdown(filename) {
            console.log(`尝试加载 Markdown: ${filename}`);
            contentDiv.innerHTML = '正在加载...';
            try {
                // 对于 GitHub Pages, filename 已经是相对于站点根目录的正确路径
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`获取文件失败: ${response.status} ${response.statusText}`);
                }
                const markdownText = await response.text();
                const htmlContent = marked.parse(markdownText);
                contentDiv.innerHTML = htmlContent;
                document.title = filename; // 更新页面标题
                console.log(`成功加载并渲染: ${filename}`);
            } catch (error) {
                console.error('加载 Markdown 失败:', error);
                contentDiv.innerHTML = `<p style="color:red;">加载 <strong>${filename}</strong> 失败。</p><p>${error.message}</p><p>请确保文件存在并且路径正确。</p>`;
                document.title = "加载失败";
            }
        }

        function checkHashAndLoad() {
            let filename = window.location.hash.substring(1);
            if (!filename) {
                // 尝试从目录树中找到第一个 Markdown 文件作为默认
                const firstMdLink = document.querySelector('#directory-tree a.file-md');
                if (firstMdLink) {
                    filename = firstMdLink.getAttribute('href').substring(1);
                     window.location.hash = '#' + filename; // 更新 hash，但不立即加载，让 hashchange 处理
                     // loadMarkdown(filename); // 或者直接加载
                     return; // 如果设置了 hash, hashchange 会处理
                } else {
                    filename = 'README.md'; // 默认回退
                }
            }
            if (!filename.toLowerCase().endsWith('.md') && filename !== 'README.md') {
                 // 如果 hash 不是 .md 结尾，并且也不是默认的 README.md (因为它可能没有 .md 后缀)
                 // 可以选择显示提示信息，或者尝试加载 README.md
                 console.log(`非 Markdown 文件: ${filename}, 尝试加载 README.md`);
                 if (filename !== 'README.md') filename = 'README.md'; // 避免死循环
            }
            loadMarkdown(filename);
        }

        // --- 初始化 ---
        async function initializeApp() {
            inferGitHubPagesConfig(); // 首先尝试自动推断配置
            await displayDirectoryTree();  // 然后加载目录树
            checkHashAndLoad();        // 最后根据 hash (或默认) 加载 Markdown
        }

        window.addEventListener('DOMContentLoaded', initializeApp);
        window.addEventListener('hashchange', checkHashAndLoad);

    </script>
</body>
</html>