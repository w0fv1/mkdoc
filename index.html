<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MkDoc</title>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown-dark.min.css" />
    <script>
        // Tailwind CDN: disable preflight to avoid interfering with github-markdown-css and browser defaults.
        window.tailwind = { config: { corePlugins: { preflight: false } } };
    </script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/vue@2.7.16/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>
</head>

<body class="m-0 min-h-screen bg-slate-950 text-slate-200 font-sans">
        <div id="app" class="flex h-screen min-h-screen w-full flex-col md:flex-row">
            <div id="sidebar"
                class="flex max-h-[40vh] w-full flex-col overflow-y-auto border-b border-slate-700 bg-slate-900 p-5 md:max-h-none md:w-72 md:min-w-[200px] md:max-w-[400px] md:border-b-0 md:border-r">
                <div class="mb-3 flex shrink-0 flex-wrap items-center justify-between gap-2 border-b border-slate-700 pb-2.5">
                    <h3 class="m-0 text-sm font-semibold tracking-wide text-slate-400">{{ t('contents') }}</h3>
                    <div id="directory-actions" class="flex gap-2">
                        <button @click="refreshDirectory" :disabled="isLoadingDirectory"
                            class="rounded border border-slate-700 bg-slate-800 px-3 py-1.5 text-xs text-slate-200 transition-colors hover:bg-slate-700 disabled:cursor-not-allowed disabled:opacity-60">
                            {{ t('reload') }}
                        </button>
                    </div>
                </div>

                <div id="directory-cache-info" v-if="directoryCacheInfo" class="mb-2 text-xs text-slate-400">{{
                    directoryCacheInfo }}</div>
                <div id="directory-notice-display" v-if="directoryNotice" v-html="directoryNotice"
                    class="mb-2 whitespace-pre-wrap rounded border border-sky-900 bg-sky-950/60 px-2.5 py-2 text-sm text-sky-200">
                </div>

                <div id="directory-error-display" v-if="directoryError" v-html="directoryError"
                    class="mb-2 whitespace-pre-wrap rounded border border-red-900 bg-red-950/60 px-2.5 py-2 text-sm text-red-200">
                </div>

                <div id="directory-tree-container" class="flex-1 overflow-y-auto">
                    <div v-if="isLoadingDirectory" class="text-sm text-slate-400">{{ t('loading_contents') }}</div>
                    <div v-html="directoryTreeHtml" id="directory-tree" class="text-sm"></div>
                </div>

                <details id="directory-advanced" class="mt-3 shrink-0 border-t border-slate-700 pt-3">
                    <summary class="cursor-pointer select-none text-sm text-slate-400">{{ t('advanced') }}</summary>
                    <div id="directory-debug-display" v-if="directoryDebug" v-html="directoryDebug"
                        class="mt-2 whitespace-pre-wrap rounded border border-sky-900 bg-sky-950/60 px-2.5 py-2 text-sm text-sky-200">
                    </div>
                    <div id="directory-treefile-hint" v-if="treeFileHint"
                        class="mt-2 whitespace-pre-wrap rounded border border-emerald-900 bg-emerald-950/40 px-2.5 py-2 text-sm text-emerald-200">
                        <div v-html="treeFileHint"></div>
                        <button @click="copyTreeFileContent" :disabled="!treeFileCopyPayload"
                            class="mt-2 rounded border border-slate-700 bg-slate-800 px-3 py-1.5 text-xs text-slate-200 transition-colors hover:bg-slate-700 disabled:cursor-not-allowed disabled:opacity-60">
                            {{ t('copy_index_file') }}
                        </button>
                    </div>
                    <div id="directory-advanced-actions" class="mt-2 flex gap-2">
                        <button @click="clearDirectoryCache" :disabled="isLoadingDirectory"
                            class="rounded border border-slate-700 bg-slate-800 px-3 py-1.5 text-xs text-slate-200 transition-colors hover:bg-slate-700 disabled:cursor-not-allowed disabled:opacity-60">
                            {{ t('clear_cache') }}
                        </button>
                    </div>
                </details>
            </div>

            <div id="main-content" class="flex flex-1 flex-col overflow-y-auto p-4 md:p-5">
                <div id="content-error-display" v-if="contentError" v-html="contentError"
                    class="mb-2 whitespace-pre-wrap rounded border border-red-900 bg-red-950/60 px-2.5 py-2 text-sm text-red-200">
                </div>
                <div id="content" class="markdown-body box-border flex-1 w-full min-w-[200px] max-w-[980px] mx-auto p-4 md:p-6"
                    v-html="renderedMarkdown">
                    <!-- Content will be rendered here by Vue -->
                </div>
            </div>
        </div>

    <script>
        // --- Vue Application ---
        new Vue({
            el: '#app',
            data: {
                config: { // Default configurations, can be overridden
                    AUTO_INFER_CONFIG: true,
                    GITHUB_OWNER: null,
                    GITHUB_REPO: null,
                    GITHUB_BRANCH: 'main',
                    PAGES_ROOT_IN_REPO: '',
                    DEFAULT_MARKDOWN_FILE: 'README.md',
                    API_BASE_URL: 'https://api.github.com',
                    TREE_CACHE_TTL_MS: 1000 * 60 * 60 * 6,
                    TREE_FILE_NAME: 'mkdoc.tree.json',
                },
                isLoadingDirectory: true,
                directoryTreeHtml: '',
                directoryError: null, // For errors related to fetching/building directory
                directoryCacheInfo: '',
                directoryNotice: '',
                directoryDebug: '',
                treeFileHint: '',
                treeFileCopyPayload: '',
                lang: ((navigator && navigator.language) ? navigator.language : 'en').toLowerCase(),

                currentMarkdownPath: '',
                renderedMarkdown: 'Loading...',
                contentError: null, // For errors related to fetching/rendering markdown

                _rawGitTree: [] // To store the fetched git tree items
            },
            computed: {
                isZh() {
                    return (this.lang || '').startsWith('zh');
                }
            },
            watch: {},
            created() {
                console.log("[VueApp] Vue instance created.");
                this.initializeConfiguration();
                this.initializeApp();
                window.addEventListener('hashchange', this.handleHashChange);
                this.handleHashChange(); // Initial load based on hash or default
            },
            beforeDestroy() {
                window.removeEventListener('hashchange', this.handleHashChange);
            },
            methods: {
                t(key) {
                    const dict = {
                        contents: { en: 'Contents', zh: '目录' },
                        reload: { en: 'Reload', zh: '刷新' },
                        advanced: { en: 'More', zh: '更多' },
                        clear_cache: { en: 'Clear saved list', zh: '清除缓存' },
                        copy_index_file: { en: 'Copy index file content', zh: '复制目录索引内容' },
                        loading_contents: { en: 'Loading…', zh: '加载中…' },
                        refreshing: { en: 'Refreshing…', zh: '刷新中…' },
                        cache_cleared: { en: 'Cleared', zh: '已清除' },
                        last_updated: { en: 'Last updated', zh: '更新时间' },
                        confirm_clear_cache: { en: 'Clear the saved directory list on this device?', zh: '确认清除本设备保存的目录缓存？' },
                        notice_treefile_failed: { en: 'Could not read the directory index file; switching to the online list.', zh: '无法读取目录索引文件，已切换为在线目录。' },
                        notice_rate_limit_cache: { en: 'Online access is temporarily limited; showing the saved list.', zh: '在线访问暂时受限，正在显示已保存的目录。' },
                        notice_tree_truncated: { en: 'Some items may be missing in the list.', zh: '目录可能不完整（部分条目可能缺失）。' },
                        notice_offline_cache: { en: 'Offline — showing the saved list.', zh: '离线状态：显示已保存的目录。' },
                        notice_index_copied: { en: 'Index content copied.', zh: '索引内容已复制。' },
                        notice_copy_failed: { en: 'Copy failed. Please copy manually.', zh: '复制失败，请手动复制。' }
                    };
                    const entry = dict[key];
                    if (!entry) return String(key);
                    return this.isZh ? (entry.zh || entry.en) : (entry.en || entry.zh);
                },
                // --- 1. Configuration ---
                initializeConfiguration() {
                    console.log("[Config] Initializing configuration...");
                    // Allow overriding config from a global object if needed for deployment
                    if (window.AppConfig && typeof window.AppConfig === 'object') {
                        this.config = { ...this.config, ...window.AppConfig };
                        console.log("[Config] Overridden config with window.AppConfig:", this.config);
                    }

                    if (this.config.AUTO_INFER_CONFIG) {
                        this.inferGitHubPagesConfig();
                    } else {
                        console.log("[Config] AUTO_INFER_CONFIG is false. Skipping automatic inference.");
                    }
                    console.log(`[Config] Effective GitHub settings: Owner='${this.config.GITHUB_OWNER}', Repo='${this.config.GITHUB_REPO}', Branch='${this.config.GITHUB_BRANCH}', PagesRoot='${this.config.PAGES_ROOT_IN_REPO}'`);
                },
                inferGitHubPagesConfig() {
                    console.log("[ConfigInfer] Starting config inference...");
                    const hostname = window.location.hostname;
                    const pathname = window.location.pathname;
                    if (!hostname.endsWith(".github.io")) {
                        console.warn(`[ConfigInfer] Hostname '${hostname}' is not a standard GitHub Pages domain. Manual GITHUB_OWNER/GITHUB_REPO in AppConfig recommended if you want to use the GitHub API.`);
                        return;
                    }

                    let inferredOwner = hostname.split('.')[0];
                    let inferredRepo = null;

                    if (hostname === `${inferredOwner}.github.io`) {
                        const pathSegments = pathname.split('/').filter(Boolean);
                        inferredRepo = pathSegments.length > 0 ? pathSegments[0] : `${inferredOwner}.github.io`;
                    } else {
                        // Should not reach here since we guard on .github.io above.
                    }

                    if (this.config.GITHUB_OWNER === null) this.config.GITHUB_OWNER = inferredOwner;
                    if (this.config.GITHUB_REPO === null && inferredRepo) this.config.GITHUB_REPO = inferredRepo;

                    console.log(`[ConfigInfer] Post-inference: Owner='${this.config.GITHUB_OWNER}', Repo='${this.config.GITHUB_REPO}'`);
                },

                // --- 2. GitHub API & Directory Logic ---
                getCacheKey() {
                    const parts = [
                        this.config.GITHUB_OWNER,
                        this.config.GITHUB_REPO,
                        this.config.GITHUB_BRANCH,
                        this.config.PAGES_ROOT_IN_REPO || ''
                    ];
                    return `mkdoc:gitTree:${parts.join('|')}`;
                },
                readCachedTreeAny() {
                    try {
                        const raw = localStorage.getItem(this.getCacheKey());
                        if (!raw) return null;
                        const parsed = JSON.parse(raw);
                        if (!parsed || !Array.isArray(parsed.tree) || !parsed.fetchedAt) return null;
                        return parsed;
                    } catch (error) {
                        console.warn("[Cache] Failed to read cache:", error);
                        return null;
                    }
                },
                readCachedTree() {
                    const parsed = this.readCachedTreeAny();
                    if (!parsed) return null;
                    const ageMs = Date.now() - parsed.fetchedAt;
                    if (ageMs > this.config.TREE_CACHE_TTL_MS) return null;
                    return parsed;
                },
                getTreeFilePath() {
                    return this.config.TREE_FILE_NAME || '';
                },
                normalizeTreeItems(items) {
                    if (!Array.isArray(items)) return [];
                    const normalized = [];
                    items.forEach(item => {
                        if (!item || !item.path) return;
                        const rawType = (item.type || '').toString().toLowerCase();
                        let type = rawType;
                        if (rawType === 'file') type = 'blob';
                        if (rawType === 'folder' || rawType === 'dir' || rawType === 'directory') type = 'tree';
                        if (type !== 'blob' && type !== 'tree') type = 'blob';
                        normalized.push({ path: String(item.path), type });
                    });
                    return normalized;
                },
                extractTreeItemsFromFile(payload) {
                    if (!payload) return null;
                    if (Array.isArray(payload)) return this.normalizeTreeItems(payload);
                    if (Array.isArray(payload.items)) return this.normalizeTreeItems(payload.items);
                    if (Array.isArray(payload.tree)) return this.normalizeTreeItems(payload.tree);
                    return null;
                },
                createTreeFilePayload(items, rootHint) {
                    return {
                        version: 1,
                        generatedAt: new Date().toISOString(),
                        root: rootHint || '',
                        items: this.normalizeTreeItems(items)
                    };
                },
                async fetchTreeFile() {
                    const treeFilePath = this.getTreeFilePath();
                    if (!treeFilePath) return null;
                    try {
                        const response = await fetch(treeFilePath, { cache: "no-store" });
                        if (response.status === 404) return null;
                        if (!response.ok) {
                        throw new Error(`Directory tree file request failed: ${response.status} ${response.statusText}`);
                        }
                        const text = await response.text();
                        const payload = JSON.parse(text);
                        const items = this.extractTreeItemsFromFile(payload);
                        if (!items || items.length === 0) {
                            throw new Error("Directory tree file content is empty or invalid");
                        }
                        return { items, payload };
                    } catch (error) {
                        console.warn("[TreeFile] Failed to load tree file:", error);
                        this.directoryNotice = this.t('notice_treefile_failed');
                        this.directoryDebug = `Tree file read failed (<code>${this.getTreeFilePath()}</code>); falling back to GitHub API.<br>${error.message}`;
                        return null;
                    }
                },
                setTreeFileHintFromGitHub(items) {
                    const rootHint = this.config.PAGES_ROOT_IN_REPO || '.';
                    const treeFilePath = this.getTreeFilePath() || 'mkdoc.tree.json';
                    if (this.isZh) {
                        this.treeFileHint = `未找到目录索引文件 <code>${treeFilePath}</code>。你可以生成并提交该文件，以减少在线请求、加快加载。<br>` +
                            `可运行：<code>node scripts/mkdoc-generate-tree.mjs --root ${rootHint} --out ${treeFilePath}</code><br>` +
                            `或点击下方按钮复制索引内容，然后手动创建并提交该文件。`;
                    } else {
                        this.treeFileHint = `Directory index file <code>${treeFilePath}</code> not found. You can generate and commit it to reduce online requests and load faster.<br>` +
                            `Run: <code>node scripts/mkdoc-generate-tree.mjs --root ${rootHint} --out ${treeFilePath}</code><br>` +
                            `Or click the button below to copy the index content and create the file manually.`;
                    }
                    const payload = this.createTreeFilePayload(items, this.config.PAGES_ROOT_IN_REPO || '');
                    this.treeFileCopyPayload = JSON.stringify(payload, null, 2);
                },
                async copyTreeFileContent() {
                    if (!this.treeFileCopyPayload) return;
                    const ok = await this.copyTextToClipboard(this.treeFileCopyPayload);
                    if (ok) {
                        this.directoryNotice = this.t('notice_index_copied');
                    } else {
                        this.directoryNotice = this.t('notice_copy_failed');
                    }
                },
                async copyTextToClipboard(text) {
                    try {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            await navigator.clipboard.writeText(text);
                            return true;
                        }
                    } catch (error) {
                        console.warn("[Clipboard] Clipboard API failed:", error);
                    }
                    try {
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        textarea.setAttribute('readonly', '');
                        textarea.style.position = 'absolute';
                        textarea.style.left = '-9999px';
                        document.body.appendChild(textarea);
                        textarea.select();
                        const ok = document.execCommand('copy');
                        document.body.removeChild(textarea);
                        return ok;
                    } catch (error) {
                        console.warn("[Clipboard] execCommand copy failed:", error);
                        return false;
                    }
                },
                writeCachedTree(tree, etag) {
                    try {
                        const payload = { tree, fetchedAt: Date.now(), etag: etag || null };
                        localStorage.setItem(this.getCacheKey(), JSON.stringify(payload));
                    } catch (error) {
                        console.warn("[Cache] Failed to write cache:", error);
                    }
                },
                clearCachedTree() {
                    try {
                        localStorage.removeItem(this.getCacheKey());
                    } catch (error) {
                        console.warn("[Cache] Failed to clear cache:", error);
                    }
                },
                formatCacheInfo(fetchedAt) {
                    const date = new Date(fetchedAt);
                    return `${this.t('last_updated')}: ${date.toLocaleString()}`;
                },
                async fetchGitHubTree(forceRefresh = false) {
                    this.isLoadingDirectory = true;
                    this.directoryError = null;
                    this.directoryNotice = '';
                    this.directoryDebug = '';
                    if (!this.config.GITHUB_OWNER || !this.config.GITHUB_REPO || !this.config.GITHUB_BRANCH) {
                        console.warn("[API] GitHub config missing; skipping GitHub API directory fetch.");
                        return null;
                    }

                    const cachedAny = this.readCachedTreeAny();
                    if (!forceRefresh) {
                        const cached = this.readCachedTree();
                        if (cached) {
                            console.log("[Cache] Using cached GitHub tree.");
                            this._rawGitTree = cached.tree || [];
                            this.directoryCacheInfo = this.formatCacheInfo(cached.fetchedAt);
                            return this._rawGitTree;
                        }
                    }

                    const apiUrl = `${this.config.API_BASE_URL}/repos/${this.config.GITHUB_OWNER}/${this.config.GITHUB_REPO}/git/trees/${this.config.GITHUB_BRANCH}?recursive=1`;
                    console.log(`[API] Fetching tree from: ${apiUrl}`);
                    try {
                        const headers = { "Accept": "application/vnd.github.v3+json" };
                        if (cachedAny && cachedAny.etag) {
                            headers["If-None-Match"] = cachedAny.etag;
                        }
                        const response = await fetch(apiUrl, { headers });
                        console.log(`[API] Fetch tree response status: ${response.status}`);
                        if (response.status === 304 && cachedAny && cachedAny.tree) {
                            console.log("[API] Tree not modified, using cached copy.");
                            this._rawGitTree = cachedAny.tree || [];
                            this.writeCachedTree(this._rawGitTree, cachedAny.etag);
                            this.directoryCacheInfo = this.formatCacheInfo(Date.now());
                            return this._rawGitTree;
                        }
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ message: "Unable to parse error response" }));
                            const message = (errorData && errorData.message) ? String(errorData.message) : "Unknown error";
                            const isRateLimit = response.status === 403 && message.toLowerCase().includes("rate limit exceeded");
                            if (isRateLimit) {
                                const reset = response.headers.get("X-RateLimit-Reset");
                                const resetEpochSeconds = reset ? parseInt(reset, 10) : NaN;
                                const resetAt = Number.isFinite(resetEpochSeconds) ? new Date(resetEpochSeconds * 1000) : null;
                                const resetText = resetAt && !Number.isNaN(resetAt.getTime()) ? resetAt.toLocaleString() : null;

                                if (cachedAny && cachedAny.tree) {
                                    console.warn("[API] Rate limit exceeded; falling back to cached tree.");
                                    this.directoryNotice = this.t('notice_rate_limit_cache');
                                    this.directoryDebug = `GitHub API rate limit reached${resetText ? ` (resets around ${resetText})` : ''}; using the local cache.`;
                                    this._rawGitTree = cachedAny.tree || [];
                                    this.directoryCacheInfo = this.formatCacheInfo(cachedAny.fetchedAt);
                                    return this._rawGitTree;
                                }
                                throw new Error(`GitHub API rate limit exceeded${resetText ? ` (resets around ${resetText})` : ''}. Please try again later or refresh less frequently.`);
                            }
                            throw new Error(`GitHub API error: ${response.status} - ${message}`);
                        }
                        const data = await response.json();
                        if (data.truncated) {
                            console.warn("[API] GitHub API tree data truncated.");
                            this.directoryNotice = this.t('notice_tree_truncated');
                            this.directoryDebug = "Note: GitHub truncated the repository tree, so some files may not appear.";
                        }
                        this._rawGitTree = data.tree || [];
                        const etag = response.headers.get("ETag");
                        this.writeCachedTree(this._rawGitTree, etag);
                        this.directoryCacheInfo = this.formatCacheInfo(Date.now());
                        console.log(`[API] Fetched ${this._rawGitTree.length} items.`);
                        return this._rawGitTree;
                    } catch (error) {
                        console.error('[API] Failed to fetch GitHub tree:', error);
                        this.directoryError = `Failed to fetch the directory tree: ${error.message}<br>Please check the console and network connection.`;
                        this.isLoadingDirectory = false;
                        return null;
                    }
                },
                buildTreeData(items) {
                    const tree = {};
                    if (!items) return tree;
                    console.log(`[BuildTree] Building tree from ${items.length} raw items.`);
                    let displayedItemCount = 0;

                    items.forEach(item => {
                        let effectivePath = item.path;
                        let shouldInclude = true;

                        if (this.config.PAGES_ROOT_IN_REPO) {
                            if (item.path.startsWith(this.config.PAGES_ROOT_IN_REPO + '/')) {
                                effectivePath = item.path.substring(this.config.PAGES_ROOT_IN_REPO.length + 1);
                            } else if (item.path === this.config.PAGES_ROOT_IN_REPO) {
                                shouldInclude = false; // Don't list the root dir itself
                            } else {
                                shouldInclude = false; // Outside pages root
                            }
                        }
                        if (!shouldInclude || !effectivePath) return;
                        displayedItemCount++;

                        const parts = effectivePath.split('/');
                        let currentLevel = tree;
                        parts.forEach((part, index) => {
                            if (!currentLevel[part]) {
                                const isDir = (item.type === 'tree' && index === parts.length - 1) || (index < parts.length - 1);
                                currentLevel[part] = { _type: isDir ? 'folder' : 'file', _name: part, _children: {} };
                            }
                            if (index === parts.length - 1) {
                                currentLevel[part]._type = (item.type === 'blob') ? 'file' : 'folder';
                                if (item.type === 'blob') currentLevel[part]._path = effectivePath;
                            }
                            currentLevel = currentLevel[part]._children;
                        });
                    });
                    console.log(`[BuildTree] Tree built. ${displayedItemCount} items included after filtering.`);
                    if (displayedItemCount === 0 && items.length > 0) {
                        this.directoryError = `No files or folders were found in the directory. This might be because <code>PAGES_ROOT_IN_REPO</code> ('${this.config.PAGES_ROOT_IN_REPO}') is set incorrectly, or because the directory is actually empty.`;
                    }
                    return tree;
                },
                renderDirectoryTreeHtml(node) {
                    let html = '<ul class="list-none pl-4">';
                    const sortedKeys = Object.keys(node).sort((a, b) => {
                        const aIsDir = node[a]._type === 'folder';
                        const bIsDir = node[b]._type === 'folder';
                        if (aIsDir && !bIsDir) return -1;
                        if (!aIsDir && bIsDir) return 1;
                        return a.localeCompare(b);
                    });

                    for (const key of sortedKeys) {
                        const item = node[key];
                        html += '<li class="mb-1">';
                        if (item._type === 'folder') {
                            html += `<span class="font-semibold text-slate-200">${item._name}</span>`;
                            if (Object.keys(item._children).length > 0) {
                                html += this.renderDirectoryTreeHtml(item._children);
                            }
                        } else if (item._type === 'file') {
                            if (item._path && item._name.toLowerCase().endsWith('.md')) {
                                html += `<a href="#${item._path}" class="text-sky-400 hover:underline">${item._name}</a>`;
                            } else {
                                html += `<span class="text-slate-400">${item._name}</span>`;
                            }
                        }
                        html += '</li>';
                    }
                    html += '</ul>';
                    return html;
                },
                async displayDirectory(forceRefresh = false) {
                    this.isLoadingDirectory = true;
                    this.directoryError = null;
                    this.directoryNotice = '';
                    this.directoryDebug = '';
                    this.treeFileHint = '';
                    this.treeFileCopyPayload = '';
                    this.directoryTreeHtml = '';
                    if (!forceRefresh && !this.directoryCacheInfo) {
                        const cached = this.readCachedTree();
                        if (cached) {
                            this.directoryCacheInfo = this.formatCacheInfo(cached.fetchedAt);
                        }
                    }
                    const treeFileResult = await this.fetchTreeFile();
                    if (treeFileResult && treeFileResult.items) {
                        this.directoryDebug = `Directory source: index file <code>${this.getTreeFilePath()}</code>`;
                        const directoryData = this.buildTreeData(treeFileResult.items);
                        this.directoryTreeHtml = this.renderDirectoryTreeHtml(directoryData);
                        if (!this.directoryTreeHtml && !this.directoryError) {
                            this.directoryTreeHtml = '<p>The directory is empty or contains no Markdown files.</p>';
                        }
                        this.isLoadingDirectory = false;
                        return;
                    }

                    const treeItems = await this.fetchGitHubTree(forceRefresh);
                    if (treeItems) {
                        this.directoryDebug = (this.directoryDebug ? `${this.directoryDebug}<br>` : '') + "Directory source: GitHub API";
                        const directoryData = this.buildTreeData(treeItems);
                        this.directoryTreeHtml = this.renderDirectoryTreeHtml(directoryData);
                        if (!this.directoryTreeHtml && !this.directoryError) {
                            this.directoryTreeHtml = '<p>The directory is empty or contains no Markdown files.</p>';
                        }
                        this.setTreeFileHintFromGitHub(treeItems);
                        this.isLoadingDirectory = false;
                        return;
                    }

                    const cachedAny = this.readCachedTree();
                    if (cachedAny && cachedAny.tree) {
                        this.directoryNotice = this.t('notice_offline_cache');
                        this.directoryDebug = "GitHub API unavailable; falling back to the local cached directory.";
                        this.directoryCacheInfo = this.formatCacheInfo(cachedAny.fetchedAt);
                        const directoryData = this.buildTreeData(cachedAny.tree || []);
                        this.directoryTreeHtml = this.renderDirectoryTreeHtml(directoryData);
                        if (!this.directoryTreeHtml && !this.directoryError) {
                            this.directoryTreeHtml = '<p>The directory is empty or contains no Markdown files.</p>';
                        }
                    }

                    if (!this.directoryTreeHtml && !this.directoryError) {
                        const treeFilePath = this.getTreeFilePath() || 'mkdoc.tree.json';
                        if (!this.config.GITHUB_OWNER || !this.config.GITHUB_REPO) {
                            this.directoryError = this.isZh
                                ? `无法加载目录：未找到 <code>${treeFilePath}</code>，且未配置 GitHub 仓库信息。请先生成并放置该文件，或在 <code>AppConfig</code> 中配置 <code>GITHUB_OWNER</code>/<code>GITHUB_REPO</code>。`
                                : `Unable to load the directory: <code>${treeFilePath}</code> was not found, and GitHub repository settings are not configured. Please add the index file, or set <code>GITHUB_OWNER</code>/<code>GITHUB_REPO</code> in <code>AppConfig</code>.`;
                        }
                    }
                    this.isLoadingDirectory = false;
                },
                async refreshDirectory() {
                    this.directoryCacheInfo = this.t('refreshing');
                    await this.displayDirectory(true);
                },
                clearDirectoryCache() {
                    if (!confirm(this.t('confirm_clear_cache'))) return;
                    this.clearCachedTree();
                    this.directoryCacheInfo = this.t('cache_cleared');
                    this.directoryNotice = '';
                    this.directoryDebug = '';
                },

                // --- 3. Markdown Rendering ---
                async loadAndRenderMarkdown(path) {
                    console.log(`[Markdown] Attempting to load: '${path}'`);
                    this.renderedMarkdown = 'Loading...';
                    this.contentError = null;
                    document.title = `Loading - ${path}`;
                    this.currentMarkdownPath = path;

                    try {
                        const response = await fetch(path); // path is relative to site root
                        console.log(`[Markdown] Fetch status for '${path}': ${response.status}`);
                        if (!response.ok) {
                            if (path === this.config.DEFAULT_MARKDOWN_FILE && response.status === 404) {
                                throw new Error(`Failed to fetch the file: ${response.status} ${response.statusText}. The default file <strong>${this.config.DEFAULT_MARKDOWN_FILE}</strong> was not found; please add it to the repository.`);
                            }
                            throw new Error(`Failed to fetch the file: ${response.status} ${response.statusText}`);
                        }
                        const markdownText = await response.text();
                        const unsafeHtml = marked.parse(markdownText);
                        if (window.DOMPurify) {
                            this.renderedMarkdown = DOMPurify.sanitize(unsafeHtml);
                        } else {
                            this.renderedMarkdown = unsafeHtml;
                            this.contentError = "Security warning: DOMPurify did not load, so raw HTML is being rendered.";
                        }
                        document.title = path;
                        console.log(`[Markdown] Successfully rendered: '${path}'`);
                    } catch (error) {
                        console.error(`[Markdown] Error loading '${path}':`, error);
                        this.contentError = `Loading <strong>${path}</strong> failed: ${error.message}`;
                        this.renderedMarkdown = ''; // Clear content area on error
                        document.title = `Load failed - ${path}`;
                    }
                },

                // --- 4. Application Logic & Event Handling ---
                handleHashChange() {
                    console.log("[AppLogic] Hash changed or initial load. Current hash:", window.location.hash);
                    let pathFromHash = window.location.hash.substring(1);

                    if (!pathFromHash) {
                        console.log("[AppLogic] No path in hash, using default:", this.config.DEFAULT_MARKDOWN_FILE);
                        pathFromHash = this.config.DEFAULT_MARKDOWN_FILE;
                        // Optionally, update hash to reflect the default, but be careful of loops
                        // window.history.replaceState(null, null, '#' + pathFromHash);
                    }

                    // Only load if the path is different from the current one, or if current is empty (initial load)
                    if (pathFromHash && pathFromHash !== this.currentMarkdownPath) {
                        this.loadAndRenderMarkdown(pathFromHash);
                    } else if (!pathFromHash && !this.currentMarkdownPath) { // Initial load, no hash, default file
                        this.loadAndRenderMarkdown(this.config.DEFAULT_MARKDOWN_FILE);
                    } else {
                        console.log("[AppLogic] Path from hash is same as current or empty, no new load triggered for:", pathFromHash);
                    }
                },
                async initializeApp() {
                    console.log("[AppInit] Initializing application...");
                    await this.displayDirectory();
                    // Initial content load is now handled by created() calling handleHashChange()
                    console.log("[AppInit] Application initialized.");
                }
            }
        });

        // Optional: For overriding Vue AppConfig easily from another script or HTML
        // window.AppConfig = {
        //     GITHUB_OWNER: "your_username",
        //     GITHUB_REPO: "your_repo_name",
        //     GITHUB_BRANCH: "main", // or "gh-pages"
        //     PAGES_ROOT_IN_REPO: "", // or "docs"
        //     TREE_FILE_NAME: "mkdoc.tree.json"
        // };
    </script>
</body>

</html>
