<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Markdown 查看器与目录</title>

    <!-- 引入 GitHub 风格 Markdown 暗黑模式样式 -->
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown-dark.min.css" />

    <style>
        body {
            margin: 0;
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            display: flex; /* 使用 Flexbox 布局 */
            min-height: 100vh;
        }

        #sidebar {
            width: 280px;
            min-width: 200px;
            max-width: 400px;
            background-color: #161b22; /* GitHub Darker Sidebar */
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #30363d; /* GitHub Dark Border */
            height: 100vh; /* 使侧边栏撑满视口高度 */
            box-sizing: border-box;
        }

        #sidebar h3 {
            margin-top: 0;
            color: #8b949e; /* GitHub Dark Secondary Text */
            border-bottom: 1px solid #30363d;
            padding-bottom: 10px;
        }

        #directory-tree ul {
            list-style-type: none;
            padding-left: 15px;
        }

        #directory-tree li {
            margin-bottom: 5px;
        }

        #directory-tree a {
            color: #58a6ff; /* GitHub Dark Link */
            text-decoration: none;
            cursor: pointer;
        }
        #directory-tree a:hover {
            text-decoration: underline;
        }
        .folder {
            font-weight: bold;
            color: #c9d1d9; /* GitHub Dark Text */
        }
        .file { /* Style for non-markdown files */
            color: #8b949e; /* GitHub Dark Secondary Text */
        }
        .file-md {
            /* Can add specific styles for Markdown files if needed */
        }


        #main-content {
            flex-grow: 1; /* 主内容区域占据剩余空间 */
            overflow-y: auto; /* 内容过多时主内容区滚动 */
            height: 100vh; /* 主内容区域也撑满视口高度 */
            box-sizing: border-box;
        }

        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            margin: 0 auto;
            padding: 45px;
        }

        @media (max-width: 767px) {
            body {
                flex-direction: column; /* 移动端上下布局 */
            }
            #sidebar {
                width: 100%;
                max-width: none;
                height: auto; /* 移动端高度自适应 */
                max-height: 40vh; /* 给侧边栏一个最大高度 */
                border-right: none;
                border-bottom: 1px solid #30363d;
            }
            #main-content {
                height: auto;
            }
            .markdown-body {
                padding: 15px;
            }
        }
    </style>
</head>

<body>
    <div id="sidebar">
        <h3>文件目录</h3>
        <div id="directory-tree">正在加载目录...</div>
    </div>

    <div id="main-content">
        <div id="content" class="markdown-body">
            正在加载...
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>

    <!-- 1. Application Configuration -->
    <script>
        const AppConfig = {
            // 是否自动推断 GitHub Owner 和 Repo。如果为 false，则必须手动设置下面的 GITHUB_OWNER 和 GITHUB_REPO。
            AUTO_INFER_CONFIG: true,

            // --- 手动配置 (如果 AUTO_INFER_CONFIG 为 false，或需要覆盖自动推断) ---
            // 将这些值设置为 null 以允许自动推断 (如果 AUTO_INFER_CONFIG 为 true)
            GITHUB_OWNER: null,  // 例如: "w0fv1"
            GITHUB_REPO: null,   // 例如: "mkdoc" 或 "w0fv1.github.io"
            // --------------------------------------------------------------------

            // --- GitHub Pages 发布源设置 (通常需要根据实际情况调整) ---
            GITHUB_BRANCH: 'main', // Pages 发布源的分支 (e.g., 'main', 'master', 'gh-pages')
            // 如果 Pages 是从仓库的子目录 (如 'docs') 发布的，请设置此项。
            // 例如: 'docs'。如果从仓库根目录发布，则留空 ''。
            PAGES_ROOT_IN_REPO: '',
            // -----------------------------------------------------------

            DEFAULT_MARKDOWN_FILE: 'README.md',
            API_BASE_URL: 'https://api.github.com',
            // GITHUB_TOKEN: null, // 用于私有仓库 (不推荐直接硬编码)

            // DOM Element IDs
            SIDEBAR_TREE_ID: 'directory-tree',
            MAIN_CONTENT_ID: 'content'
        };
    </script>

    <!-- 2. GitHub API Utilities -->
    <script>
        function inferGitHubPagesConfig() {
            console.log("[ConfigInfer] Starting configuration inference process...");
            console.log(`[ConfigInfer] Initial AppConfig values: Owner=${AppConfig.GITHUB_OWNER}, Repo=${AppConfig.GITHUB_REPO}, Branch=${AppConfig.GITHUB_BRANCH}, Root='${AppConfig.PAGES_ROOT_IN_REPO}'`);
            console.log(`[ConfigInfer] Current URL: Hostname='${window.location.hostname}', Pathname='${window.location.pathname}'`);

            let inferredOwnerFromHostname = window.location.hostname.split('.')[0];
            let inferredRepoFromPath = null;

            // 检查是否是标准 GitHub Pages 域名 (owner.github.io)
            if (window.location.hostname === `${inferredOwnerFromHostname}.github.io`) {
                console.log("[ConfigInfer] Hostname matches 'owner.github.io' pattern.");
                const pathSegments = window.location.pathname.split('/').filter(Boolean); // 移除空字符串

                if (pathSegments.length > 0) {
                    // 对于 owner.github.io/repo-name/ 结构，第一个路径段是仓库名
                    inferredRepoFromPath = pathSegments[0];
                    console.log(`[ConfigInfer] Potential GITHUB_REPO (project page type): '${inferredRepoFromPath}' from first path segment.`);
                } else {
                    // 对于 owner.github.io/ (无后续路径)，仓库名是 owner.github.io
                    inferredRepoFromPath = `${inferredOwnerFromHostname}.github.io`;
                    console.log(`[ConfigInfer] Potential GITHUB_REPO (user/org page type): '${inferredRepoFromPath}'.`);
                }
            } else {
                // 自定义域名或其他非标准设置
                console.warn(`[ConfigInfer] Hostname '${window.location.hostname}' is a custom domain or non-standard. Cannot reliably infer GITHUB_REPO. GITHUB_OWNER and GITHUB_REPO should be manually set in AppConfig.`);
                // 对于自定义域名，我们无法从 URL 推断仓库名，但所有者可能仍可从 AppConfig.GITHUB_OWNER 获取
                // 如果 GITHUB_OWNER 也未手动设置，inferredOwnerFromHostname 可能是错误的 (例如 www)
            }

            // 仅当 AppConfig 中的对应字段为 null (未手动设置) 时，才应用推断值
            if (AppConfig.GITHUB_OWNER === null) {
                AppConfig.GITHUB_OWNER = inferredOwnerFromHostname;
                console.log(`[ConfigInfer] Applied inferred GITHUB_OWNER: '${AppConfig.GITHUB_OWNER}'`);
            } else {
                console.log(`[ConfigInfer] GITHUB_OWNER was manually set to: '${AppConfig.GITHUB_OWNER}'. Inference for owner skipped.`);
            }

            if (AppConfig.GITHUB_REPO === null && inferredRepoFromPath !== null) {
                AppConfig.GITHUB_REPO = inferredRepoFromPath;
                console.log(`[ConfigInfer] Applied inferred GITHUB_REPO: '${AppConfig.GITHUB_REPO}'`);
            } else if (AppConfig.GITHUB_REPO !== null) {
                console.log(`[ConfigInfer] GITHUB_REPO was manually set to: '${AppConfig.GITHUB_REPO}'. Inference for repo skipped.`);
            } else { // AppConfig.GITHUB_REPO is null AND inferredRepoFromPath is null (e.g., custom domain)
                console.warn(`[ConfigInfer] Could not apply inferred GITHUB_REPO (inference was not possible or yielded null). GITHUB_REPO remains: '${AppConfig.GITHUB_REPO}'. Manual configuration is likely required.`);
            }

            console.log(`[ConfigInfer] Effective config after inference: Owner='${AppConfig.GITHUB_OWNER}', Repo='${AppConfig.GITHUB_REPO}', Branch='${AppConfig.GITHUB_BRANCH}', PagesRoot='${AppConfig.PAGES_ROOT_IN_REPO}'`);
            console.log("[ConfigInfer] Inference process complete.");
        }

        async function fetchGitHubTree() {
            if (!AppConfig.GITHUB_OWNER || !AppConfig.GITHUB_REPO || !AppConfig.GITHUB_BRANCH) {
                console.error("[API] GitHub fetchTree PRE-CHECK FAILED: Config incomplete! Owner, Repo, or Branch is missing.");
                console.error(`[API] Current Config: Owner=${AppConfig.GITHUB_OWNER}, Repo=${AppConfig.GITHUB_REPO}, Branch=${AppConfig.GITHUB_BRANCH}`);
                document.getElementById(AppConfig.SIDEBAR_TREE_ID).innerHTML =
                    `<p style="color:red;"><strong>配置错误:</strong> GitHub Owner, Repository, 或 Branch 未设置。无法加载目录。</p>`;
                return null;
            }
            const apiUrl = `${AppConfig.API_BASE_URL}/repos/${AppConfig.GITHUB_OWNER}/${AppConfig.GITHUB_REPO}/git/trees/${AppConfig.GITHUB_BRANCH}?recursive=1`;
            console.log(`[API] Fetching tree from: ${apiUrl}`);
            try {
                const headers = { "Accept": "application/vnd.github.v3+json" };
                if (AppConfig.GITHUB_TOKEN) {
                    // headers["Authorization"] = `token ${AppConfig.GITHUB_TOKEN}`;
                    console.warn("[API] 注意：在前端使用 GitHub Token 有安全风险。仅用于测试或受信任环境。");
                }
                const response = await fetch(apiUrl, { headers });
                console.log(`[API] Fetch tree response status: ${response.status}`);
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ message: "Unknown error, could not parse error response." }));
                    console.error(`[API] GitHub API Error Data:`, errorData);
                    throw new Error(`GitHub API Error: ${response.status} - ${errorData.message || 'No message'}`);
                }
                const data = await response.json();
                if (data.truncated) {
                    console.warn("[API] GitHub API 返回的树信息被截断 (truncated=true)，可能无法显示所有文件。");
                }
                console.log(`[API] Successfully fetched ${data.tree ? data.tree.length : 0} items from tree API.`);
                return data.tree;
            } catch (error) {
                console.error('[API] 获取 GitHub 目录树失败:', error);
                document.getElementById(AppConfig.SIDEBAR_TREE_ID).innerHTML =
                    `<p style="color:red;">加载目录失败: ${error.message}</p>
                     <p>请检查控制台获取更多信息，并确认 AppConfig 中的 GitHub 配置是否正确，以及网络连接是否正常。</p>`;
                return null;
            }
        }

        function buildTree(items) {
            const tree = {};
            if (!items) {
                console.warn("[BuildTree] Input items array is null or undefined. Returning empty tree.");
                return tree;
            }
            console.log(`[BuildTree] Received ${items.length} raw items from API to build tree.`);
            let processedItemsCount = 0;

            items.forEach(item => {
                let effectivePath = item.path;
                let shouldInclude = true;

                if (AppConfig.PAGES_ROOT_IN_REPO) {
                    if (item.path.startsWith(AppConfig.PAGES_ROOT_IN_REPO + '/')) {
                        effectivePath = item.path.substring(AppConfig.PAGES_ROOT_IN_REPO.length + 1);
                    } else if (item.path === AppConfig.PAGES_ROOT_IN_REPO) {
                        // This is the root directory itself (e.g., 'docs' if PAGES_ROOT_IN_REPO is 'docs')
                        // We don't want to list it as a separate item in the tree if it's the base.
                        shouldInclude = false;
                    } else { // Item is outside the PAGES_ROOT_IN_REPO
                        shouldInclude = false;
                    }
                }

                if (!shouldInclude || !effectivePath) { // Also skip if effectivePath becomes empty
                    // console.log(`[BuildTree] Skipping item (path: '${item.path}') due to PAGES_ROOT_IN_REPO filter or empty effectivePath.`);
                    return;
                }
                processedItemsCount++;

                const parts = effectivePath.split('/');
                let currentLevel = tree;
                parts.forEach((part, index) => {
                    if (!currentLevel[part]) {
                        // Determine if it's a folder: if it's a 'tree' type from API, OR if it's not the last part of the path.
                        const isDir = (item.type === 'tree' && index === parts.length -1) || (index < parts.length - 1);
                        currentLevel[part] = { _type: isDir ? 'folder' : 'file', _children: {} };
                    }
                    // If it's the last part, ensure type and path are correctly set for files
                    if (index === parts.length - 1) {
                        currentLevel[part]._type = (item.type === 'blob') ? 'file' : 'folder'; // 'tree' from API means folder
                        if (item.type === 'blob') { // file
                            currentLevel[part]._path = effectivePath;
                        }
                    }
                    currentLevel = currentLevel[part]._children;
                });
            });
            console.log(`[BuildTree] Processed ${processedItemsCount} items after PAGES_ROOT_IN_REPO filtering. Tree structure built.`);
            return tree;
        }
    </script>

    <!-- 3. Directory Renderer -->
    <script>
        function renderTree(node, currentLevelPath = '') { // Changed currentPath to currentLevelPath for clarity
            let html = '<ul>';
            const sortedKeys = Object.keys(node).sort((a, b) => {
                const aIsDir = node[a]._type === 'folder';
                const bIsDir = node[b]._type === 'folder';
                if (aIsDir && !bIsDir) return -1;
                if (!aIsDir && bIsDir) return 1;
                return a.localeCompare(b);
            });

            // console.log(`[RenderTree] Rendering level with keys: ${sortedKeys.join(', ')} at path: ${currentLevelPath}`);

            for (const key of sortedKeys) {
                const item = node[key];
                html += '<li>';
                if (item._type === 'folder') {
                    html += `<span class="folder">${key}</span>`;
                    if (Object.keys(item._children).length > 0) {
                        // For folders, the path passed to children is built up from currentLevelPath and key
                        const folderPath = currentLevelPath ? `${currentLevelPath}/${key}` : key;
                        html += renderTree(item._children, folderPath);
                    }
                } else if (item._type === 'file') {
                    // Files should have _path directly from buildTree, which is relative to site root
                    const filePath = item._path;
                    if (!filePath) {
                        console.error(`[RenderTree] File item '${key}' is missing _path property. This should not happen.`, item);
                        html += `<span class="file" style="color:red;">${key} (Error: missing path)</span>`;
                    } else if (key.toLowerCase().endsWith('.md')) {
                        html += `<a href="#${filePath}" class="file-md">${key}</a>`;
                    } else {
                        html += `<span class="file">${key}</span>`;
                    }
                }
                html += '</li>';
            }
            html += '</ul>';
            return html;
        }

        async function displayDirectoryTree() {
            console.log("[DirDisplay] Attempting to display directory tree...");
            const directoryElement = document.getElementById(AppConfig.SIDEBAR_TREE_ID);
            if (!directoryElement) {
                console.error(`[DirDisplay] CRITICAL: Directory container element '#${AppConfig.SIDEBAR_TREE_ID}' not found in DOM!`);
                return;
            }
            directoryElement.innerHTML = '正在加载目录...';
            const treeItems = await fetchGitHubTree();
            if (treeItems) {
                const directoryData = buildTree(treeItems);
                if (Object.keys(directoryData).length === 0 && treeItems.length > 0) {
                    console.warn("[DirDisplay] Tree data is empty after buildTree, but API returned items. Check PAGES_ROOT_IN_REPO and filtering logic.");
                     directoryElement.innerHTML = `<p>目录为空，或所有文件均在 <code>${AppConfig.PAGES_ROOT_IN_REPO || '仓库根'}</code> 目录之外。</p><p>请检查 <code>AppConfig.PAGES_ROOT_IN_REPO</code> 配置。</p>`;
                } else if (Object.keys(directoryData).length === 0 && treeItems.length === 0) {
                    directoryElement.innerHTML = '<p>仓库目录为空。</p>';
                }
                else {
                    const treeHtml = renderTree(directoryData);
                    directoryElement.innerHTML = treeHtml || '<p>目录为空或未找到 Markdown 文件。</p>'; // Fallback if renderTree returns empty
                    console.log("[DirDisplay] Directory tree rendered.");
                }
            } else {
                 console.log("[DirDisplay] fetchGitHubTree returned no items. Directory display aborted or error message shown by fetchGitHubTree.");
            }
        }
    </script>

    <!-- 4. Markdown Renderer -->
    <script>
        async function loadMarkdown(filename) {
            const contentDiv = document.getElementById(AppConfig.MAIN_CONTENT_ID);
            if (!contentDiv) {
                console.error(`[MarkdownLoad] CRITICAL: Content container element '#${AppConfig.MAIN_CONTENT_ID}' not found in DOM!`);
                return;
            }
            console.log(`[MarkdownLoad] Attempting to load Markdown: '${filename}'`);
            contentDiv.innerHTML = '正在加载...';
            document.title = `加载中 - ${filename}`;

            try {
                // filename is expected to be relative to the GitHub Pages site root
                const response = await fetch(filename);
                console.log(`[MarkdownLoad] Fetch response status for '${filename}': ${response.status}`);
                if (!response.ok) {
                    throw new Error(`获取文件失败: ${response.status} ${response.statusText} (文件: ${filename})`);
                }
                const markdownText = await response.text();
                const htmlContent = marked.parse(markdownText);
                contentDiv.innerHTML = htmlContent;
                document.title = filename;
                console.log(`[MarkdownLoad] Successfully loaded and rendered: '${filename}'`);
            } catch (error) {
                console.error(`[MarkdownLoad] Error loading Markdown file '${filename}':`, error);
                contentDiv.innerHTML = `<p style="color:red;">加载 <strong>${filename}</strong> 失败。</p><p>${error.message}</p><p>请确保文件存在并且路径相对于网站根目录是正确的。</p>`;
                document.title = `加载失败 - ${filename}`;
            }
        }
    </script>

    <!-- 5. Main Application Logic -->
    <script>
        function checkHashAndLoad() {
            console.log("[AppLogic] checkHashAndLoad triggered.");
            let filename = window.location.hash.substring(1);
            console.log(`[AppLogic] Current hash: '${window.location.hash}', Parsed filename from hash: '${filename}'`);

            if (!filename) {
                console.log("[AppLogic] No filename in hash. Attempting to find default Markdown file.");
                const firstMdLink = document.querySelector(`#${AppConfig.SIDEBAR_TREE_ID} a.file-md`);
                if (firstMdLink) {
                    filename = firstMdLink.getAttribute('href').substring(1);
                    console.log(`[AppLogic] Found first Markdown file in directory: '${filename}'. Updating hash.`);
                    window.location.hash = '#' + filename; // This will re-trigger hashchange, leading to load.
                    return; // Let the new hashchange event handle the loading.
                } else {
                    filename = AppConfig.DEFAULT_MARKDOWN_FILE;
                    console.log(`[AppLogic] No Markdown files in directory or default '${AppConfig.DEFAULT_MARKDOWN_FILE}' will be used: '${filename}'`);
                }
            }

            if (filename) {
                console.log(`[AppLogic] Determined filename to load: '${filename}'`);
                loadMarkdown(filename);
            } else {
                 console.warn("[AppLogic] No filename could be determined to load.");
                 const contentDiv = document.getElementById(AppConfig.MAIN_CONTENT_ID);
                 if (contentDiv) {
                    contentDiv.innerHTML = `<p>请从目录中选择一个文件，或确保默认文件 (<code>${AppConfig.DEFAULT_MARKDOWN_FILE}</code>) 存在。</p>`;
                 }
                 document.title = "请选择文件";
            }
        }

        async function initializeApp() {
            console.log("[AppInit] Initializing application...");
            if (AppConfig.AUTO_INFER_CONFIG) {
                inferGitHubPagesConfig();
            } else {
                console.log("[AppInit] AUTO_INFER_CONFIG is false. Skipping automatic configuration inference.");
                console.log(`[AppInit] Using manually set AppConfig values: Owner='${AppConfig.GITHUB_OWNER}', Repo='${AppConfig.GITHUB_REPO}', Branch='${AppConfig.GITHUB_BRANCH}', PagesRoot='${AppConfig.PAGES_ROOT_IN_REPO}'`);
            }

            console.log(`[AppInit] Final GitHub Config for API calls: Owner='${AppConfig.GITHUB_OWNER}', Repo='${AppConfig.GITHUB_REPO}', Branch='${AppConfig.GITHUB_BRANCH}'`);

            if (!AppConfig.GITHUB_OWNER || !AppConfig.GITHUB_REPO) {
                console.error("[AppInit] CRITICAL CONFIGURATION ERROR: GITHUB_OWNER or GITHUB_REPO is not set or is invalid.");
                console.error(`[AppInit] Current values: Owner='${AppConfig.GITHUB_OWNER}', Repo='${AppConfig.GITHUB_REPO}'`);
                const errorMsg = `<p style="color:red;"><strong>配置错误:</strong> GitHub Owner 或 Repository 未正确设置。</p>
                                  <p>请检查控制台日志。如果 <code>AUTO_INFER_CONFIG</code> 为 true，确保 URL 结构可被正确解析。
                                  否则，请在 <code>AppConfig</code> 中手动设置 <code>GITHUB_OWNER</code> 和 <code>GITHUB_REPO</code>。</p>`;
                const sidebarDiv = document.getElementById(AppConfig.SIDEBAR_TREE_ID);
                const contentDiv = document.getElementById(AppConfig.MAIN_CONTENT_ID);
                if (sidebarDiv) sidebarDiv.innerHTML = errorMsg;
                if (contentDiv) contentDiv.innerHTML = "";
                return; // Stop further initialization
            }

            await displayDirectoryTree();
            checkHashAndLoad();
            console.log("[AppInit] Application initialized successfully.");
        }

        window.addEventListener('DOMContentLoaded', () => {
            console.log("[DOM] DOMContentLoaded event fired.");
            initializeApp();
        });
        window.addEventListener('hashchange', () => {
            console.log("[Hash] hashchange event fired.");
            checkHashAndLoad();
        });
    </script>

</body>
</html>