<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue Markdown 查看器</title>
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.8.1/github-markdown-dark.min.css" />
    <script src="https://unpkg.com/vue@2.7.16/dist/vue.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/4.2.12/marked.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dompurify/3.0.8/purify.min.js"></script>

    <style>
        body {
            margin: 0;
            background-color: #0d1117;
            color: #c9d1d9;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji";
            display: flex;
            min-height: 100vh;
        }

        #app {
            /* Vue app root */
            display: flex;
            width: 100%;
            height: 100vh;
        }

        #sidebar {
            width: 280px;
            min-width: 200px;
            max-width: 400px;
            background-color: #161b22;
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid #30363d;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
        }

        #sidebar h3 {
            margin-top: 0;
            color: #8b949e;
            border-bottom: 1px solid #30363d;
            padding-bottom: 10px;
            flex-shrink: 0;
            /* Prevent h3 from shrinking */
        }

        #directory-error-display,
        #content-error-display {
            background-color: #2c0b0b;
            /* Dark red background for errors */
            color: #ff8383;
            /* Light red text for errors */
            padding: 10px;
            margin-bottom: 10px;
            border: 1px solid #581e1e;
            border-radius: 4px;
            font-size: 0.9em;
            white-space: pre-wrap;
            /* Preserve line breaks in error messages */
            flex-shrink: 0;
            /* Prevent error display from shrinking */
        }

        #directory-error-display:empty,
        #content-error-display:empty {
            display: none;
            /* Hide if no error */
        }

        #directory-notice-display {
            background-color: #0d1f2b;
            color: #8ec7ff;
            padding: 8px 10px;
            margin-bottom: 10px;
            border: 1px solid #1b3a55;
            border-radius: 4px;
            font-size: 0.9em;
            white-space: pre-wrap;
            flex-shrink: 0;
        }

        #directory-notice-display:empty {
            display: none;
        }

        #directory-treefile-hint {
            background-color: #112016;
            color: #9de6b5;
            padding: 8px 10px;
            margin-bottom: 10px;
            border: 1px solid #214a2b;
            border-radius: 4px;
            font-size: 0.9em;
            white-space: pre-wrap;
            flex-shrink: 0;
        }

        #directory-treefile-hint button {
            margin-top: 8px;
        }

        #directory-tree-container {
            flex-grow: 1;
            /* Allow tree to take remaining space and scroll */
            overflow-y: auto;
        }

        #directory-actions {
            display: flex;
            gap: 8px;
            margin: 10px 0 12px;
        }

        #directory-actions button {
            background-color: #21262d;
            color: #c9d1d9;
            border: 1px solid #30363d;
            padding: 6px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        #directory-actions button:hover {
            background-color: #2d333b;
        }

        #directory-actions button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #directory-cache-info {
            color: #8b949e;
            font-size: 12px;
            margin-bottom: 8px;
        }

        #directory-tree ul {
            list-style-type: none;
            padding-left: 15px;
        }

        #directory-tree li {
            margin-bottom: 5px;
        }

        #directory-tree a {
            color: #58a6ff;
            text-decoration: none;
            cursor: pointer;
        }

        #directory-tree a:hover {
            text-decoration: underline;
        }

        .folder {
            font-weight: bold;
            color: #c9d1d9;
        }

        .file {
            color: #8b949e;
        }

        #main-content {
            flex-grow: 1;
            overflow-y: auto;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            padding: 20px;
            /* Add padding here instead of markdown-body for error display positioning */
        }

        .markdown-body {
            box-sizing: border-box;
            min-width: 200px;
            max-width: 980px;
            width: 100%;
            margin: 0 auto;
            /* Center markdown content */
            padding: 25px;
            /* Original padding for markdown content itself */
            flex-grow: 1;
            /* Allow markdown body to take space */
        }


        @media (max-width: 767px) {
            #app {
                flex-direction: column;
            }

            #sidebar {
                width: 100%;
                max-width: none;
                height: auto;
                max-height: 40vh;
                border-right: none;
                border-bottom: 1px solid #30363d;
            }

            #main-content {
                height: auto;
                padding: 15px;
            }

            .markdown-body {
                padding: 15px;
            }
        }
    </style>
</head>

<body>
    <div id="app">
        <div id="sidebar">
            <h3>文件目录</h3>
            <div id="directory-actions">
                <button @click="refreshDirectory" :disabled="isLoadingDirectory">手动拉取</button>
                <button @click="clearDirectoryCache" :disabled="isLoadingDirectory">清除缓存</button>
            </div>
            <div id="directory-cache-info" v-if="directoryCacheInfo">{{ directoryCacheInfo }}</div>
            <div id="directory-notice-display" v-if="directoryNotice" v-html="directoryNotice"></div>
            <div id="directory-treefile-hint" v-if="treeFileHint">
                <div v-html="treeFileHint"></div>
                <button @click="copyTreeFileContent" :disabled="!treeFileCopyPayload">复制目录树文件内容</button>
            </div>
            <div id="directory-error-display" v-if="directoryError" v-html="directoryError"></div>
            <div id="directory-tree-container">
                <div v-if="isLoadingDirectory">正在加载目录...</div>
                <div v-html="directoryTreeHtml" id="directory-tree"></div>
            </div>
        </div>

        <div id="main-content">
            <div id="content-error-display" v-if="contentError" v-html="contentError"></div>
            <div id="content" class="markdown-body" v-html="renderedMarkdown">
                <!-- Content will be rendered here by Vue -->
            </div>
        </div>
    </div>

    <script>
        // --- Vue Application ---
        new Vue({
            el: '#app',
            data: {
                config: { // Default configurations, can be overridden
                    AUTO_INFER_CONFIG: true,
                    GITHUB_OWNER: null,
                    GITHUB_REPO: null,
                    GITHUB_BRANCH: 'main',
                    PAGES_ROOT_IN_REPO: '',
                    DEFAULT_MARKDOWN_FILE: 'README.md',
                    API_BASE_URL: 'https://api.github.com',
                    TREE_CACHE_TTL_MS: 1000 * 60 * 60 * 6,
                    TREE_FILE_NAME: 'mkdoc.tree.json',
                },
                isLoadingDirectory: true,
                directoryTreeHtml: '',
                directoryError: null, // For errors related to fetching/building directory
                directoryCacheInfo: '',
                directoryNotice: '',
                treeFileHint: '',
                treeFileCopyPayload: '',

                currentMarkdownPath: '',
                renderedMarkdown: '正在加载...',
                contentError: null, // For errors related to fetching/rendering markdown

                _rawGitTree: [] // To store the fetched git tree items
            },
            computed: {
                // You can add computed properties if needed
            },
            watch: {},
            created() {
                console.log("[VueApp] Vue instance created.");
                this.initializeConfiguration();
                this.initializeApp();
                window.addEventListener('hashchange', this.handleHashChange);
                this.handleHashChange(); // Initial load based on hash or default
            },
            beforeDestroy() {
                window.removeEventListener('hashchange', this.handleHashChange);
            },
            methods: {
                // --- 1. Configuration ---
                initializeConfiguration() {
                    console.log("[Config] Initializing configuration...");
                    // Allow overriding config from a global object if needed for deployment
                    if (window.AppConfig && typeof window.AppConfig === 'object') {
                        this.config = { ...this.config, ...window.AppConfig };
                        console.log("[Config] Overridden config with window.AppConfig:", this.config);
                    }

                    if (this.config.AUTO_INFER_CONFIG) {
                        this.inferGitHubPagesConfig();
                    } else {
                        console.log("[Config] AUTO_INFER_CONFIG is false. Skipping automatic inference.");
                    }
                    console.log(`[Config] Effective GitHub settings: Owner='${this.config.GITHUB_OWNER}', Repo='${this.config.GITHUB_REPO}', Branch='${this.config.GITHUB_BRANCH}', PagesRoot='${this.config.PAGES_ROOT_IN_REPO}'`);
                },
                inferGitHubPagesConfig() {
                    console.log("[ConfigInfer] Starting config inference...");
                    const hostname = window.location.hostname;
                    const pathname = window.location.pathname;
                    let inferredOwner = hostname.split('.')[0];
                    let inferredRepo = null;

                    if (hostname === `${inferredOwner}.github.io`) {
                        const pathSegments = pathname.split('/').filter(Boolean);
                        inferredRepo = pathSegments.length > 0 ? pathSegments[0] : `${inferredOwner}.github.io`;
                    } else {
                        console.warn(`[ConfigInfer] Hostname '${hostname}' is custom or non-standard. Manual GITHUB_OWNER/GITHUB_REPO in AppConfig recommended.`);
                        // For custom domains, repo cannot be reliably inferred from URL. Owner might be from hostname.
                    }

                    if (this.config.GITHUB_OWNER === null) this.config.GITHUB_OWNER = inferredOwner;
                    if (this.config.GITHUB_REPO === null && inferredRepo) this.config.GITHUB_REPO = inferredRepo;

                    console.log(`[ConfigInfer] Post-inference: Owner='${this.config.GITHUB_OWNER}', Repo='${this.config.GITHUB_REPO}'`);
                },

                // --- 2. GitHub API & Directory Logic ---
                getCacheKey() {
                    const parts = [
                        this.config.GITHUB_OWNER,
                        this.config.GITHUB_REPO,
                        this.config.GITHUB_BRANCH,
                        this.config.PAGES_ROOT_IN_REPO || ''
                    ];
                    return `mkdoc:gitTree:${parts.join('|')}`;
                },
                readCachedTreeAny() {
                    try {
                        const raw = localStorage.getItem(this.getCacheKey());
                        if (!raw) return null;
                        const parsed = JSON.parse(raw);
                        if (!parsed || !Array.isArray(parsed.tree) || !parsed.fetchedAt) return null;
                        return parsed;
                    } catch (error) {
                        console.warn("[Cache] Failed to read cache:", error);
                        return null;
                    }
                },
                readCachedTree() {
                    const parsed = this.readCachedTreeAny();
                    if (!parsed) return null;
                    const ageMs = Date.now() - parsed.fetchedAt;
                    if (ageMs > this.config.TREE_CACHE_TTL_MS) return null;
                    return parsed;
                },
                getTreeFilePath() {
                    return this.config.TREE_FILE_NAME || '';
                },
                normalizeTreeItems(items) {
                    if (!Array.isArray(items)) return [];
                    const normalized = [];
                    items.forEach(item => {
                        if (!item || !item.path) return;
                        const rawType = (item.type || '').toString().toLowerCase();
                        let type = rawType;
                        if (rawType === 'file') type = 'blob';
                        if (rawType === 'folder' || rawType === 'dir' || rawType === 'directory') type = 'tree';
                        if (type !== 'blob' && type !== 'tree') type = 'blob';
                        normalized.push({ path: String(item.path), type });
                    });
                    return normalized;
                },
                extractTreeItemsFromFile(payload) {
                    if (!payload) return null;
                    if (Array.isArray(payload)) return this.normalizeTreeItems(payload);
                    if (Array.isArray(payload.items)) return this.normalizeTreeItems(payload.items);
                    if (Array.isArray(payload.tree)) return this.normalizeTreeItems(payload.tree);
                    return null;
                },
                createTreeFilePayload(items, rootHint) {
                    return {
                        version: 1,
                        generatedAt: new Date().toISOString(),
                        root: rootHint || '',
                        items: this.normalizeTreeItems(items)
                    };
                },
                async fetchTreeFile() {
                    const treeFilePath = this.getTreeFilePath();
                    if (!treeFilePath) return null;
                    try {
                        const response = await fetch(treeFilePath, { cache: "no-store" });
                        if (response.status === 404) return null;
                        if (!response.ok) {
                            throw new Error(`目录树文件请求失败: ${response.status} ${response.statusText}`);
                        }
                        const text = await response.text();
                        const payload = JSON.parse(text);
                        const items = this.extractTreeItemsFromFile(payload);
                        if (!items || items.length === 0) {
                            throw new Error("目录树文件内容为空或格式不正确");
                        }
                        return { items, payload };
                    } catch (error) {
                        console.warn("[TreeFile] Failed to load tree file:", error);
                        this.directoryNotice = `目录树文件读取失败，已回退到 GitHub API。<br>${error.message}`;
                        return null;
                    }
                },
                setTreeFileHintFromGitHub(items) {
                    const rootHint = this.config.PAGES_ROOT_IN_REPO || '.';
                    const treeFilePath = this.getTreeFilePath() || 'mkdoc.tree.json';
                    this.treeFileHint = `未发现目录树文件 <code>${treeFilePath}</code>。建议在仓库中生成并提交该文件以避免 API 限流。<br>` +
                        `可运行：<code>node scripts/mkdoc-generate-tree.mjs --root ${rootHint} --out ${treeFilePath}</code><br>` +
                        `或点击下方按钮复制目录树文件内容后自行新建并提交。`;
                    const payload = this.createTreeFilePayload(items, this.config.PAGES_ROOT_IN_REPO || '');
                    this.treeFileCopyPayload = JSON.stringify(payload, null, 2);
                },
                async copyTreeFileContent() {
                    if (!this.treeFileCopyPayload) return;
                    const ok = await this.copyTextToClipboard(this.treeFileCopyPayload);
                    if (ok) {
                        this.directoryNotice = "目录树文件内容已复制到剪贴板，可新建文件并提交到仓库。";
                    } else {
                        this.directoryNotice = "复制失败，请手动复制目录树文件内容。";
                    }
                },
                async copyTextToClipboard(text) {
                    try {
                        if (navigator.clipboard && navigator.clipboard.writeText) {
                            await navigator.clipboard.writeText(text);
                            return true;
                        }
                    } catch (error) {
                        console.warn("[Clipboard] Clipboard API failed:", error);
                    }
                    try {
                        const textarea = document.createElement('textarea');
                        textarea.value = text;
                        textarea.setAttribute('readonly', '');
                        textarea.style.position = 'absolute';
                        textarea.style.left = '-9999px';
                        document.body.appendChild(textarea);
                        textarea.select();
                        const ok = document.execCommand('copy');
                        document.body.removeChild(textarea);
                        return ok;
                    } catch (error) {
                        console.warn("[Clipboard] execCommand copy failed:", error);
                        return false;
                    }
                },
                writeCachedTree(tree, etag) {
                    try {
                        const payload = { tree, fetchedAt: Date.now(), etag: etag || null };
                        localStorage.setItem(this.getCacheKey(), JSON.stringify(payload));
                    } catch (error) {
                        console.warn("[Cache] Failed to write cache:", error);
                    }
                },
                clearCachedTree() {
                    try {
                        localStorage.removeItem(this.getCacheKey());
                    } catch (error) {
                        console.warn("[Cache] Failed to clear cache:", error);
                    }
                },
                formatCacheInfo(fetchedAt) {
                    const date = new Date(fetchedAt);
                    return `缓存时间: ${date.toLocaleString()}`;
                },
                async fetchGitHubTree(forceRefresh = false) {
                    this.isLoadingDirectory = true;
                    this.directoryError = null;
                    this.directoryNotice = '';
                    if (!this.config.GITHUB_OWNER || !this.config.GITHUB_REPO || !this.config.GITHUB_BRANCH) {
                        const errorMsg = "<strong>配置错误:</strong> GitHub Owner, Repository, 或 Branch 未设置。";
                        console.error("[API] fetchTree PRE-CHECK FAILED:", errorMsg);
                        this.directoryError = errorMsg;
                        this.isLoadingDirectory = false;
                        return null;
                    }

                    const cachedAny = this.readCachedTreeAny();
                    if (!forceRefresh) {
                        const cached = this.readCachedTree();
                        if (cached) {
                            console.log("[Cache] Using cached GitHub tree.");
                            this._rawGitTree = cached.tree || [];
                            this.directoryCacheInfo = this.formatCacheInfo(cached.fetchedAt);
                            return this._rawGitTree;
                        }
                    }

                    const apiUrl = `${this.config.API_BASE_URL}/repos/${this.config.GITHUB_OWNER}/${this.config.GITHUB_REPO}/git/trees/${this.config.GITHUB_BRANCH}?recursive=1`;
                    console.log(`[API] Fetching tree from: ${apiUrl}`);
                    try {
                        const headers = { "Accept": "application/vnd.github.v3+json" };
                        if (cachedAny && cachedAny.etag) {
                            headers["If-None-Match"] = cachedAny.etag;
                        }
                        const response = await fetch(apiUrl, { headers });
                        console.log(`[API] Fetch tree response status: ${response.status}`);
                        if (response.status === 304 && cachedAny && cachedAny.tree) {
                            console.log("[API] Tree not modified, using cached copy.");
                            this._rawGitTree = cachedAny.tree || [];
                            this.writeCachedTree(this._rawGitTree, cachedAny.etag);
                            this.directoryCacheInfo = this.formatCacheInfo(Date.now());
                            return this._rawGitTree;
                        }
                        if (!response.ok) {
                            const errorData = await response.json().catch(() => ({ message: "无法解析错误响应" }));
                            const message = (errorData && errorData.message) ? String(errorData.message) : "未知错误";
                            const isRateLimit = response.status === 403 && message.toLowerCase().includes("rate limit exceeded");
                            if (isRateLimit) {
                                const reset = response.headers.get("X-RateLimit-Reset");
                                const resetEpochSeconds = reset ? parseInt(reset, 10) : NaN;
                                const resetAt = Number.isFinite(resetEpochSeconds) ? new Date(resetEpochSeconds * 1000) : null;
                                const resetText = resetAt && !Number.isNaN(resetAt.getTime()) ? resetAt.toLocaleString() : null;

                                if (cachedAny && cachedAny.tree) {
                                    console.warn("[API] Rate limit exceeded; falling back to cached tree.");
                                    this.directoryNotice = `GitHub API 达到速率限制${resetText ? `（预计 ${resetText} 重置）` : ''}，已使用本地缓存目录。`;
                                    this._rawGitTree = cachedAny.tree || [];
                                    this.directoryCacheInfo = this.formatCacheInfo(cachedAny.fetchedAt);
                                    return this._rawGitTree;
                                }
                                throw new Error(`GitHub API 速率限制已用尽${resetText ? `（预计 ${resetText} 重置）` : ''}。请稍后再试，或减少刷新频率。`);
                            }
                            throw new Error(`GitHub API 错误: ${response.status} - ${message}`);
                        }
                        const data = await response.json();
                        if (data.truncated) {
                            console.warn("[API] GitHub API 树信息被截断。");
                            this.directoryNotice = "注意: 仓库目录树被 GitHub 截断，可能无法显示完整文件列表。";
                        }
                        this._rawGitTree = data.tree || [];
                        const etag = response.headers.get("ETag");
                        this.writeCachedTree(this._rawGitTree, etag);
                        this.directoryCacheInfo = this.formatCacheInfo(Date.now());
                        console.log(`[API] Fetched ${this._rawGitTree.length} items.`);
                        return this._rawGitTree;
                    } catch (error) {
                        console.error('[API] 获取 GitHub 目录树失败:', error);
                        this.directoryError = `获取目录树失败: ${error.message}<br>请检查控制台和网络连接。`;
                        this.isLoadingDirectory = false;
                        return null;
                    }
                },
                buildTreeData(items) {
                    const tree = {};
                    if (!items) return tree;
                    console.log(`[BuildTree] Building tree from ${items.length} raw items.`);
                    let displayedItemCount = 0;

                    items.forEach(item => {
                        let effectivePath = item.path;
                        let shouldInclude = true;

                        if (this.config.PAGES_ROOT_IN_REPO) {
                            if (item.path.startsWith(this.config.PAGES_ROOT_IN_REPO + '/')) {
                                effectivePath = item.path.substring(this.config.PAGES_ROOT_IN_REPO.length + 1);
                            } else if (item.path === this.config.PAGES_ROOT_IN_REPO) {
                                shouldInclude = false; // Don't list the root dir itself
                            } else {
                                shouldInclude = false; // Outside pages root
                            }
                        }
                        if (!shouldInclude || !effectivePath) return;
                        displayedItemCount++;

                        const parts = effectivePath.split('/');
                        let currentLevel = tree;
                        parts.forEach((part, index) => {
                            if (!currentLevel[part]) {
                                const isDir = (item.type === 'tree' && index === parts.length - 1) || (index < parts.length - 1);
                                currentLevel[part] = { _type: isDir ? 'folder' : 'file', _name: part, _children: {} };
                            }
                            if (index === parts.length - 1) {
                                currentLevel[part]._type = (item.type === 'blob') ? 'file' : 'folder';
                                if (item.type === 'blob') currentLevel[part]._path = effectivePath;
                            }
                            currentLevel = currentLevel[part]._children;
                        });
                    });
                    console.log(`[BuildTree] Tree built. ${displayedItemCount} items included after filtering.`);
                    if (displayedItemCount === 0 && items.length > 0) {
                        this.directoryError = `目录中没有文件或文件夹。这可能是因为 <code>PAGES_ROOT_IN_REPO</code> ('${this.config.PAGES_ROOT_IN_REPO}') 设置不正确，或者该目录下确实为空。`;
                    }
                    return tree;
                },
                renderDirectoryTreeHtml(node) {
                    let html = '<ul>';
                    const sortedKeys = Object.keys(node).sort((a, b) => {
                        const aIsDir = node[a]._type === 'folder';
                        const bIsDir = node[b]._type === 'folder';
                        if (aIsDir && !bIsDir) return -1;
                        if (!aIsDir && bIsDir) return 1;
                        return a.localeCompare(b);
                    });

                    for (const key of sortedKeys) {
                        const item = node[key];
                        html += '<li>';
                        if (item._type === 'folder') {
                            html += `<span class="folder">${item._name}</span>`;
                            if (Object.keys(item._children).length > 0) {
                                html += this.renderDirectoryTreeHtml(item._children);
                            }
                        } else if (item._type === 'file') {
                            if (item._path && item._name.toLowerCase().endsWith('.md')) {
                                html += `<a href="#${item._path}" class="file-md">${item._name}</a>`;
                            } else {
                                html += `<span class="file">${item._name}</span>`;
                            }
                        }
                        html += '</li>';
                    }
                    html += '</ul>';
                    return html;
                },
                async displayDirectory(forceRefresh = false) {
                    this.isLoadingDirectory = true;
                    this.directoryError = null;
                    this.directoryNotice = '';
                    this.treeFileHint = '';
                    this.treeFileCopyPayload = '';
                    if (!forceRefresh && !this.directoryCacheInfo) {
                        const cached = this.readCachedTree();
                        if (cached) {
                            this.directoryCacheInfo = this.formatCacheInfo(cached.fetchedAt);
                        }
                    }
                    const treeFileResult = await this.fetchTreeFile();
                    if (treeFileResult && treeFileResult.items) {
                        this.directoryNotice = `目录树来源: 目录树文件 <code>${this.getTreeFilePath()}</code>`;
                        const directoryData = this.buildTreeData(treeFileResult.items);
                        this.directoryTreeHtml = this.renderDirectoryTreeHtml(directoryData);
                        if (!this.directoryTreeHtml && !this.directoryError) {
                            this.directoryTreeHtml = '<p>目录为空或无 Markdown 文件。</p>';
                        }
                        this.isLoadingDirectory = false;
                        return;
                    }

                    const treeItems = await this.fetchGitHubTree(forceRefresh);
                    if (treeItems) {
                        if (this.directoryNotice) {
                            this.directoryNotice += "<br>目录树来源: GitHub API";
                        } else {
                            this.directoryNotice = "目录树来源: GitHub API";
                        }
                        const directoryData = this.buildTreeData(treeItems);
                        this.directoryTreeHtml = this.renderDirectoryTreeHtml(directoryData);
                        if (!this.directoryTreeHtml && !this.directoryError) {
                            this.directoryTreeHtml = '<p>目录为空或无 Markdown 文件。</p>';
                        }
                        this.setTreeFileHintFromGitHub(treeItems);
                        this.isLoadingDirectory = false;
                        return;
                    }

                    const cachedAny = this.readCachedTree();
                    if (cachedAny && cachedAny.tree) {
                        this.directoryNotice = "GitHub API 不可用，已回退到本地缓存目录。";
                        this.directoryCacheInfo = this.formatCacheInfo(cachedAny.fetchedAt);
                        const directoryData = this.buildTreeData(cachedAny.tree || []);
                        this.directoryTreeHtml = this.renderDirectoryTreeHtml(directoryData);
                        if (!this.directoryTreeHtml && !this.directoryError) {
                            this.directoryTreeHtml = '<p>目录为空或无 Markdown 文件。</p>';
                        }
                    }
                    this.isLoadingDirectory = false;
                },
                async refreshDirectory() {
                    this.directoryCacheInfo = '正在手动拉取...';
                    await this.displayDirectory(true);
                },
                clearDirectoryCache() {
                    this.clearCachedTree();
                    this.directoryCacheInfo = '缓存已清除';
                    this.directoryNotice = '';
                },

                // --- 3. Markdown Rendering ---
                async loadAndRenderMarkdown(path) {
                    console.log(`[Markdown] Attempting to load: '${path}'`);
                    this.renderedMarkdown = '正在加载...';
                    this.contentError = null;
                    document.title = `加载中 - ${path}`;
                    this.currentMarkdownPath = path;

                    try {
                        const response = await fetch(path); // path is relative to site root
                        console.log(`[Markdown] Fetch status for '${path}': ${response.status}`);
                        if (!response.ok) {
                            if (path === this.config.DEFAULT_MARKDOWN_FILE && response.status === 404) {
                                throw new Error(`获取文件失败: ${response.status} ${response.statusText}。默认文件 <strong>${this.config.DEFAULT_MARKDOWN_FILE}</strong> 未找到，请在仓库中添加此文件。`);
                            }
                            throw new Error(`获取文件失败: ${response.status} ${response.statusText}`);
                        }
                        const markdownText = await response.text();
                        const unsafeHtml = marked.parse(markdownText);
                        if (window.DOMPurify) {
                            this.renderedMarkdown = DOMPurify.sanitize(unsafeHtml);
                        } else {
                            this.renderedMarkdown = unsafeHtml;
                            this.contentError = "安全提示: DOMPurify 未加载，已渲染未经清洗的 HTML。";
                        }
                        document.title = path;
                        console.log(`[Markdown] Successfully rendered: '${path}'`);
                    } catch (error) {
                        console.error(`[Markdown] Error loading '${path}':`, error);
                        this.contentError = `加载 <strong>${path}</strong> 失败: ${error.message}`;
                        this.renderedMarkdown = ''; // Clear content area on error
                        document.title = `加载失败 - ${path}`;
                    }
                },

                // --- 4. Application Logic & Event Handling ---
                handleHashChange() {
                    console.log("[AppLogic] Hash changed or initial load. Current hash:", window.location.hash);
                    let pathFromHash = window.location.hash.substring(1);

                    if (!pathFromHash) {
                        console.log("[AppLogic] No path in hash, using default:", this.config.DEFAULT_MARKDOWN_FILE);
                        pathFromHash = this.config.DEFAULT_MARKDOWN_FILE;
                        // Optionally, update hash to reflect the default, but be careful of loops
                        // window.history.replaceState(null, null, '#' + pathFromHash);
                    }

                    // Only load if the path is different from the current one, or if current is empty (initial load)
                    if (pathFromHash && pathFromHash !== this.currentMarkdownPath) {
                        this.loadAndRenderMarkdown(pathFromHash);
                    } else if (!pathFromHash && !this.currentMarkdownPath) { // Initial load, no hash, default file
                        this.loadAndRenderMarkdown(this.config.DEFAULT_MARKDOWN_FILE);
                    } else {
                        console.log("[AppLogic] Path from hash is same as current or empty, no new load triggered for:", pathFromHash);
                    }
                },
                async initializeApp() {
                    console.log("[AppInit] Initializing application...");
                    if (!this.config.GITHUB_OWNER || !this.config.GITHUB_REPO) {
                        this.directoryError = "<strong>致命配置错误:</strong> GITHUB_OWNER 或 GITHUB_REPO 未设置。请检查 <code>AppConfig</code> 或自动推断逻辑。";
                        this.isLoadingDirectory = false;
                        console.error("[AppInit] CRITICAL CONFIG ERROR:", this.directoryError);
                        return;
                    }
                    await this.displayDirectory();
                    // Initial content load is now handled by created() calling handleHashChange()
                    console.log("[AppInit] Application initialized.");
                }
            }
        });

        // Optional: For overriding Vue AppConfig easily from another script or HTML
        // window.AppConfig = {
        //     GITHUB_OWNER: "your_username",
        //     GITHUB_REPO: "your_repo_name",
        //     GITHUB_BRANCH: "main", // or "gh-pages"
        //     PAGES_ROOT_IN_REPO: "", // or "docs"
        //     TREE_FILE_NAME: "mkdoc.tree.json"
        // };
    </script>
</body>

</html>
